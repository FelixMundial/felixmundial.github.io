<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JVM | Felix Mundial的杂烩图书馆</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/icons/favicon.png">
    <meta name="description" content="github page powered by Vuepress">
    
    <link rel="preload" href="/assets/css/0.styles.0e3647e7.css" as="style"><link rel="preload" href="/assets/js/app.9bbd0500.js" as="script"><link rel="preload" href="/assets/js/1.7e1accfd.js" as="script"><link rel="preload" href="/assets/js/13.b5619b2f.js" as="script"><link rel="preload" href="/assets/js/21.aad032a5.js" as="script"><link rel="prefetch" href="/assets/js/10.535b18bf.js"><link rel="prefetch" href="/assets/js/11.9f4c7505.js"><link rel="prefetch" href="/assets/js/12.1040a13c.js"><link rel="prefetch" href="/assets/js/14.9065f59b.js"><link rel="prefetch" href="/assets/js/15.1af3a730.js"><link rel="prefetch" href="/assets/js/16.145ee41f.js"><link rel="prefetch" href="/assets/js/17.daef2d0a.js"><link rel="prefetch" href="/assets/js/18.ccf124a3.js"><link rel="prefetch" href="/assets/js/19.3c9e19e5.js"><link rel="prefetch" href="/assets/js/20.cbce51c7.js"><link rel="prefetch" href="/assets/js/22.d26d3f4d.js"><link rel="prefetch" href="/assets/js/23.36d5eb9b.js"><link rel="prefetch" href="/assets/js/24.3d224717.js"><link rel="prefetch" href="/assets/js/25.e67e5f2e.js"><link rel="prefetch" href="/assets/js/26.26226ddd.js"><link rel="prefetch" href="/assets/js/27.ef309e27.js"><link rel="prefetch" href="/assets/js/28.275159e4.js"><link rel="prefetch" href="/assets/js/29.f7f84fc3.js"><link rel="prefetch" href="/assets/js/3.92bf9476.js"><link rel="prefetch" href="/assets/js/4.7de240dc.js"><link rel="prefetch" href="/assets/js/5.422f2530.js"><link rel="prefetch" href="/assets/js/6.9952df18.js"><link rel="prefetch" href="/assets/js/7.b57f400b.js"><link rel="prefetch" href="/assets/js/8.a18e3f05.js"><link rel="prefetch" href="/assets/js/9.c6f1e43f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0e3647e7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="azure" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name"><i class="el-icon-bicycle"></i> Felix Mundial的杂烩图书馆</span></a> <div class="links"><nav class="nav-links can-hide"><div class="nav-item"><a href="/guide/toc.html" class="nav-link" data-v-c7dec8ac><i class="el-icon-discount"></i> Archives</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/leetcode/leetcode101.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-leetcode"></i> Leetcode</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-java"></i> Java</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/java/concurrency.html" class="nav-link" data-v-c7dec8ac>并发</a></li><li class="dropdown-item"><!----> <a href="/posts/java/jvm.html" aria-current="page" class="nav-link router-link-exact-active router-link-active" data-v-c7dec8ac>JVM</a></li><li class="dropdown-item"><!----> <a href="/posts/java/spring.html" class="nav-link" data-v-c7dec8ac>Spring</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springmvc.html" class="nav-link" data-v-c7dec8ac>Spring MVC</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springboot.html" class="nav-link" data-v-c7dec8ac>Spring Boot</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-database"></i> 数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/database/mysql.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-mysql"></i> MySQL</a></li><li class="dropdown-item"><!----> <a href="/posts/database/redis.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-redis"></i> Redis</a></li></ul></div></div> <!----></nav> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/guide/toc.html" class="nav-link" data-v-c7dec8ac><i class="el-icon-discount"></i> Archives</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/leetcode/leetcode101.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-leetcode"></i> Leetcode</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-java"></i> Java</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/java/concurrency.html" class="nav-link" data-v-c7dec8ac>并发</a></li><li class="dropdown-item"><!----> <a href="/posts/java/jvm.html" aria-current="page" class="nav-link router-link-exact-active router-link-active" data-v-c7dec8ac>JVM</a></li><li class="dropdown-item"><!----> <a href="/posts/java/spring.html" class="nav-link" data-v-c7dec8ac>Spring</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springmvc.html" class="nav-link" data-v-c7dec8ac>Spring MVC</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springboot.html" class="nav-link" data-v-c7dec8ac>Spring Boot</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-database"></i> 数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/database/mysql.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-mysql"></i> MySQL</a></li><li class="dropdown-item"><!----> <a href="/posts/database/redis.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-redis"></i> Redis</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/java/concurrency.html" class="sidebar-link">Java并发</a></li><li><a href="/posts/java/jvm.html" aria-current="page" class="active sidebar-link">JVM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/java/jvm.html#pc寄存器" class="sidebar-link">PC寄存器</a></li><li class="sidebar-sub-header"><a href="/posts/java/jvm.html#栈" class="sidebar-link">栈</a></li><li class="sidebar-sub-header"><a href="/posts/java/jvm.html#堆" class="sidebar-link">堆</a></li><li class="sidebar-sub-header"><a href="/posts/java/jvm.html#方法区" class="sidebar-link">方法区</a></li><li class="sidebar-sub-header"><a href="/posts/java/jvm.html#基本概念" class="sidebar-link">基本概念</a></li><li class="sidebar-sub-header"><a href="/posts/java/jvm.html#垃圾回收器" class="sidebar-link">垃圾回收器</a></li><li class="sidebar-sub-header"><a href="/posts/java/jvm.html#gc调优" class="sidebar-link">GC调优</a></li><li class="sidebar-sub-header"><a href="/posts/java/jvm.html#内存调优" class="sidebar-link">内存调优</a></li></ul></li><li><a href="/posts/java/spring.html" class="sidebar-link">Spring基础</a></li><li><a href="/posts/java/springboot.html" class="sidebar-link">Spring Boot基础</a></li><li><a href="/posts/java/springmvc.html" class="sidebar-link">Spring MVC基础</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="post-header" data-v-528c0c8a><h2 class="post-title" data-v-528c0c8a><a href="/posts/java/jvm.html" data-v-528c0c8a><!---->
			JVM
		</a></h2> <div class="post-meta" data-v-528c0c8a><div class="author post-meta-item" data-v-528c0c8a><i class="el-icon-bicycle" data-v-528c0c8a></i> <span data-v-528c0c8a>FelixMundial</span></div> <div class="time post-meta-item" data-v-528c0c8a><i class="el-icon-time" data-v-528c0c8a></i> <time data-v-528c0c8a>2020-11-18</time></div> <div class="category post-meta-item" data-v-528c0c8a><i class="el-icon-collection" data-v-528c0c8a></i> <a href="/category/JVM" class="category-item" data-v-528c0c8a>
				JVM
			</a></div> <div class="tags post-meta-item" data-v-528c0c8a><i class="el-icon-price-tag" data-v-528c0c8a></i> <span class="tag-item el-tag el-tag--light" data-v-528c0c8a>
				JavaSE
			</span><span class="tag-item el-tag el-tag--light" data-v-528c0c8a>
				JVM
			</span></div> <div id="/posts/java/jvm.html" data-flag-title="JVM" class="leancloud-visitors post-meta-item" data-v-528c0c8a><i class="el-icon-reading" data-v-528c0c8a></i> <span class="leancloud-visitors-count" data-v-528c0c8a>0</span></div></div></div> <div class="theme-default-content content__default"><h1 id="jvm内存分区"><a href="#jvm内存分区" class="header-anchor">#</a> JVM内存分区</h1> <h2 id="pc寄存器"><a href="#pc寄存器" class="header-anchor">#</a> PC寄存器</h2> <h2 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h2> <h3 id="栈帧"><a href="#栈帧" class="header-anchor">#</a> 栈帧</h3> <h3 id="局部变量表"><a href="#局部变量表" class="header-anchor">#</a> 局部变量表</h3> <h3 id="操作数栈"><a href="#操作数栈" class="header-anchor">#</a> 操作数栈</h3> <h5 id="本地方法栈"><a href="#本地方法栈" class="header-anchor">#</a> 本地方法栈</h5> <h2 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h2> <h3 id="堆空间"><a href="#堆空间" class="header-anchor">#</a> 堆空间</h3> <h4 id="代码优化策略"><a href="#代码优化策略" class="header-anchor">#</a> 代码优化策略</h4> <h4 id="序列化与深拷贝"><a href="#序列化与深拷贝" class="header-anchor">#</a> 序列化与深拷贝</h4> <h4 id="tlab"><a href="#tlab" class="header-anchor">#</a> TLAB</h4> <h2 id="方法区"><a href="#方法区" class="header-anchor">#</a> 方法区</h2> <h4 id="字符串常量池-全局串池"><a href="#字符串常量池-全局串池" class="header-anchor">#</a> 字符串常量池（全局串池）</h4> <p>JDK1.6中串池存在于<strong>方法区（永久代）<strong>中，只有当进行fullGC时才进行垃圾回收；JDK1.7中串池脱离方法区，存在于</strong>堆</strong>中，只要进行minorGC时就进行垃圾回收</p> <p>类加载<strong>解析阶段</strong>，在堆中生成字符串对象实例，并将该字符串对象实例的<strong>引用值</strong>存于串池（JDK1.7后位于堆）中</p> <p>HotSpot VM中的具体实现为<code>StringTable</code>（串池map），其中存储<strong>驻留字符串引用</strong>，在每个HotSpot VM实例只有一份，被所有的类共享</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> ab1 <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> ab2 <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment">// ab2 != ab1</span>
<span class="token class-name">String</span> ab3 <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">;</span> <span class="token comment">// ab3 == ab1</span>

<span class="token class-name">String</span> abi <span class="token operator">=</span> ab2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// abi != ab2且abi == ab1 == ab3（JDK1.7）</span>
</code></pre></div><ul><li><p>字面值常量（a、b、ab1）</p> <p>若在串池中未找到目标字符串对象，则创建对应的字符串对象存储于堆中，将其引用放入串池（整个过程为懒加载）</p></li> <li><p>字符串拼接表达式（ab2、ab3）</p> <ul><li>若表达式中包含变量，创建<code>StringBuilder</code>对象，分别拼接表达式变量，最后将<code>toString()</code>结果（新字符串）保存于堆中，并将其引用赋值给ab2而<strong>不放入串池</strong></li> <li>若表达式中均为常量，则在编译期进行字符串拼接，并执行字面值常量初始化流程</li></ul></li> <li><p><code>intern()</code></p> <ul><li><strong>JDK1.7</strong>：尝试将调用该方法的字符串对象引用放入串池，并返回串池中该对象的引用
<ul><li>若串池中不存在该对象引用，则返回的对象引用 <code>==</code> 当前对象引用</li> <li>若串池中已存在该对象引用，则无需将当前字符串关联串池，返回的对象引用 <code>!=</code> 当前对象引用</li></ul></li> <li><strong>JDK1.6</strong>：尝试将调用该方法的字符串对象的<strong>副本</strong>引用放入串池，并返回串池中该对象引用，因此返回的对象引用 <code>!=</code> 当前对象引用</li></ul></li></ul> <h6 id="串池调优"><a href="#串池调优" class="header-anchor">#</a> 串池调优</h6> <h4 id="class文件常量池"><a href="#class文件常量池" class="header-anchor">#</a> class文件常量池</h4> <p>类加载阶段，编译器生成的各种字面量于符号引用存储于class文件常量池（表）中。其中在类加载<strong>解析</strong>阶段，运行时常量池中符号引用被替换为直接引用，此时可能需要查询串池，以保证串池中的字符串引用值与class文件常量池中的字符串引用值一致</p> <h4 id="运行时常量池"><a href="#运行时常量池" class="header-anchor">#</a> 运行时常量池</h4> <p>类加载阶段结束后，class文件常量池中的内容转移至运行时常量池中</p> <p>JDK1.6中运行时常量池存在于**方法区（永久代）<strong>中，JDK1.8中运行时常量池存在于</strong>元空间（直接内存）**中</p> <h1 id="垃圾回收"><a href="#垃圾回收" class="header-anchor">#</a> 垃圾回收</h1> <h2 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h2> <h3 id="根对象与可达性分析"><a href="#根对象与可达性分析" class="header-anchor">#</a> 根对象与可达性分析</h3> <h6 id="根对象"><a href="#根对象" class="header-anchor">#</a> 根对象：</h6> <ul><li>强引用</li> <li>软引用</li> <li>弱引用</li> <li>虚引用</li> <li>终结器引用</li></ul> <h3 id="gc算法"><a href="#gc算法" class="header-anchor">#</a> GC算法</h3> <ul><li><p>标记-清除</p> <ol><li>标记可达对象</li> <li>清除不可达对象</li></ol> <h6 id="缺陷"><a href="#缺陷" class="header-anchor">#</a> 缺陷</h6> <ul><li>STW较长，性能较差</li> <li>碎片化严重</li></ul></li> <li><p>标记-整理</p></li> <li><p>复制</p> <h6 id="缺陷-2"><a href="#缺陷-2" class="header-anchor">#</a> 缺陷</h6> <ul><li>存货对象较多时影响性能（故不适用于老年代）</li> <li>只使用一半空间进行对象填充，内存使用率较低</li></ul></li> <li><p>分代收集（新生代使用<strong>复制算法</strong>，老年代使用标记-清除/标记-整理算法）</p></li></ul> <h3 id="gc类型"><a href="#gc类型" class="header-anchor">#</a> GC类型</h3> <ul><li><p>MinorGC</p> <p>新生代满时触发</p> <blockquote><p>以下对象将提前晋升至老年代：</p> <ul><li>长期存活的对象</li> <li>Survivor区无法容纳的大对象</li> <li>Survivor区可容纳，但复制过程过于消耗性能的大对象</li></ul></blockquote></li> <li><p>FullGC</p> <p>老年代满时触发</p></li> <li><p>OOM：某线程发生OOM将清空其占用的堆内存，而不影响其他线程</p></li></ul> <h2 id="垃圾回收器"><a href="#垃圾回收器" class="header-anchor">#</a> 垃圾回收器</h2> <h4 id="串行-不推荐使用"><a href="#串行-不推荐使用" class="header-anchor">#</a> 串行（不推荐使用）</h4> <p><code>-XX:+UseSerialGC</code>：Serial New（新生代，<strong>复制</strong>） + Serial Old（老年代，<strong>标记-清除</strong>）</p> <h4 id="并行-jdk6、7、8默认"><a href="#并行-jdk6、7、8默认" class="header-anchor">#</a> 并行（JDK6、7、8默认）</h4> <p><code>-XX:+UseParallelGC</code>/<code>-XX:+UseParallelOldGC</code>：Parallel Scavenge（新生代+老年代，<strong>复制</strong>）</p> <p>吞吐量优先，<strong>GC线程</strong>对CPU占用高</p> <p><code>-XX:GCTimeRatio=GC时间占总吞吐时间百分比</code>（默认值99%）</p> <p><code>-XX:MaxGCPauseMillis=GC最大STW时间</code></p> <h4 id="cms-并发-jdk9废弃"><a href="#cms-并发-jdk9废弃" class="header-anchor">#</a> CMS（并发，JDK9废弃）</h4> <p><code>-XX:+UseConcMarkSweepGC</code>：CMS（老年代，<strong>标记-清除</strong>；ParNew Old为备用）+ <code>-XX:+UseParNewGC</code>：ParNew New（【并行】新生代，<strong>复制</strong>）</p> <blockquote><ol><li>初始标记（STW）</li> <li>并发标记</li> <li>预清理</li> <li>重新标记（STW）</li> <li>并发清理</li> <li>并发重置</li></ol></blockquote> <p>响应时间优先，<strong>GC线程</strong>对CPU占用低</p> <p>若并发GC失败，则CMS退化为SerialOld</p> <p><code>-XX:ParallelGCThreads=并行线程（工作线程）数</code></p> <p><code>-XX:ConcGCThreads=并发线程（GC线程）数</code>（t2 = t1 / 4）</p> <p><code>-XX:CMSInitiatingOccupancyFraction</code>当老年代浮动垃圾占比达到该值时，开始执行FullGC</p> <p><code>-XX:+CMSScavengeBeforeRemark</code>执行FullGC前先使用ParNewGC对新生代进行清理，减少老年代对新生代的引用，降低重新标记阶段的资源开销</p> <p><code>-XX:UseCMSCompactAtFullCollection</code>+<code>-XX:CMSFullGCsBeforeCompaction</code>在执行FullGC之后进行老年代内存压缩，降低内存碎片出现频率</p> <h4 id="g1-jdk9默认"><a href="#g1-jdk9默认" class="header-anchor">#</a> G1（JDK9默认）</h4> <p><code>-XX:+UseG1GC</code> ：G1（<strong>区域间复制</strong> + <strong>标记-整理</strong>）</p> <h5 id="回收原理"><a href="#回收原理" class="header-anchor">#</a> 回收原理</h5> <h6 id="堆内存分区"><a href="#堆内存分区" class="header-anchor">#</a> 堆内存分区</h6> <p>在进行区域间复制的过程中，同时实现了标记-整理功能，降低内存碎片化概率</p> <ul><li>Humongous区（巨型对象区）</li></ul> <h6 id="回收流程"><a href="#回收流程" class="header-anchor">#</a> 回收流程</h6> <blockquote><h5 id="stw"><a href="#stw" class="header-anchor">#</a> STW</h5> <p><code>-XX:MaxGCPauseMillis</code></p> <p>默认STW时间为200ms</p></blockquote> <ol><li><h6 id="young-collection"><a href="#young-collection" class="header-anchor">#</a> Young Collection</h6> <blockquote><h6 id="跨代引用、remembered-set与卡表"><a href="#跨代引用、remembered-set与卡表" class="header-anchor">#</a> 跨代引用、<code>Remembered Set</code>与卡表</h6></blockquote></li> <li><h6 id="mixed-collection"><a href="#mixed-collection" class="header-anchor">#</a> Mixed Collection</h6> <p>触发时机控制：<code>-XX:InitiatingHeapOccupancyPercent</code>（默认值45%）</p> <ol><li>初始标记（STW）</li> <li>根区域扫描</li> <li>并发标记（STW）</li> <li>最终标记（STW）</li> <li>拷贝存活（Evacuation（STW）：老年代垃圾进行选择性回收，优先回收巨型对象）</li></ol></li></ol> <blockquote><h5 id="pre-write-barrier与satb-mark-queue"><a href="#pre-write-barrier与satb-mark-queue" class="header-anchor">#</a> <code>pre-write barrier</code>与<code>satb_mark_queue</code></h5></blockquote> <ul><li><h4 id="zgc"><a href="#zgc" class="header-anchor">#</a> ZGC</h4></li> <li><h4 id="epsilon、shenandoah"><a href="#epsilon、shenandoah" class="header-anchor">#</a> Epsilon、Shenandoah</h4></li></ul> <h3 id="gc性能衡量"><a href="#gc性能衡量" class="header-anchor">#</a> GC性能衡量</h3> <h4 id="衡量指标"><a href="#衡量指标" class="header-anchor">#</a> 衡量指标</h4> <h5 id="吞吐量"><a href="#吞吐量" class="header-anchor">#</a> 吞吐量</h5> <p>$\Huge{\frac{GC耗时}{应用程序耗时 + GC耗时}}$</p> <h5 id="停顿时间"><a href="#停顿时间" class="header-anchor">#</a> 停顿时间</h5> <h5 id="gc频率"><a href="#gc频率" class="header-anchor">#</a> GC频率</h5> <h4 id="衡量工具"><a href="#衡量工具" class="header-anchor">#</a> 衡量工具</h4> <p>**<code>top</code>**查看进程的内存使用情况</p> <h6 id="jstack"><a href="#jstack" class="header-anchor">#</a> <code>jstack</code></h6> <p>​	<code>jstack [PID]</code>查看具体线程的堆栈与状态信息</p> <h6 id="jstat"><a href="#jstat" class="header-anchor">#</a> <code>jstat</code></h6> <p>​	<code>jstat -class [PID]</code>/<code>jstat -compiler [PID]</code>查看类加载/类编译的数量</p> <p>​	<code>jstat -gc [PID] [打印间隔/ms] [打印次数]</code>查看堆中各个分区的内存占用情况及GC情况</p> <h6 id="jmap"><a href="#jmap" class="header-anchor">#</a> <code>jmap</code></h6> <p>​	<code>jmap -heap [PID]</code>查看堆中各个分区的内存占用情况，以及所用垃圾收集器的设置类型</p> <p>​	<code>jmap -histo[:live] [PID] | more</code>查看堆内存中的对象数目、大小统计直方图</p> <p>​	<code>jmap -dump:format=b,file=./heap.hprof [PID]</code>输出堆dump文件结合jhat/MAT进行分析</p> <p>​		<code>-XX:HeapDumpOnOutOfMemoryError</code>在发生 OOM 时输出堆dump文件</p> <h6 id="jhat"><a href="#jhat" class="header-anchor">#</a> <code>jhat</code></h6> <p>​	<code>jhat -port [PORT] ./heap.hprof</code></p> <h6 id="jinfo"><a href="#jinfo" class="header-anchor">#</a> <code>jinfo</code></h6> <p>​	<code>jinfo -flags [PID]</code></p> <h1 id="调优"><a href="#调优" class="header-anchor">#</a> ==调优==</h1> <h2 id="gc调优"><a href="#gc调优" class="header-anchor">#</a> GC调优</h2> <div class="language-bash extra-class"><pre class="language-bash"><code>-XX:+PrintGC 输出 GC 日志
-XX:+PrintGCDetails 输出 GC 的详细日志
-XX:+PrintGCTimeStamps 输出 GC 的时间戳<span class="token punctuation">(</span>以基准时间的形式<span class="token punctuation">)</span>
-XX:+PrintGCDateStamps 输出 GC 的时间戳<span class="token punctuation">(</span>以日期的形式，如 <span class="token number">2013</span>-05-04T21:53:59.234+0800<span class="token punctuation">)</span>
-XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息
-Xloggc:<span class="token punctuation">..</span>/logs/gc.log 日志文件的输出路径
</code></pre></div><p>可使用GC Viewer/GC Easy等工具对输出的GC日志文件进行分析，根据分析结果进行内存与GC调优</p> <h3 id="堆-2"><a href="#堆-2" class="header-anchor">#</a> 堆</h3> <p>无用对象的回收</p> <p><code>-XX:MaxTenuringThreshold</code>新生代对象晋升年龄阈值（最大值15）</p> <p><code>-XX:PretenureSizeThreshold</code> 新生代对象直接晋升大小阈值</p> <h5 id="降低minor-gc频率"><a href="#降低minor-gc频率" class="header-anchor">#</a> 降低Minor GC频率</h5> <ul><li><p>通过进一步增加新生代内存以降低Minor GC频率</p> <p>若新生代对象存活时间普遍较长，则不可贸然增加新生代内存，否则反而会增加Minor GC时间</p></li></ul> <h5 id="降低full-gc频率"><a href="#降低full-gc频率" class="header-anchor">#</a> 降低Full GC频率</h5> <ul><li><p>若新生代Surviver区内存紧张，则对象晋升年龄/大小可能降低（<code>-XX:+UseAdaptiveSizePolicy</code>），增大老年代Full GC概率</p> <p>故可通过<strong>适当增大堆内存空间，提高新生代对象晋升年龄与大小阈值</strong>进行缓解</p></li></ul> <h3 id="方法区-2"><a href="#方法区-2" class="header-anchor">#</a> 方法区</h3> <p>无用常量与类的回收</p> <h2 id="内存调优"><a href="#内存调优" class="header-anchor">#</a> 内存调优</h2> <ul><li><code>-Xms</code>与<code>-Xmx</code>建议配置相同的值，使得在GC后无需重新分隔计算堆区的大小</li> <li><code>-Xmn</code>新生代内存分配一般为堆内存空间的25%～50%（Sun推荐配置为整个堆内存大小的3/8）</li> <li>在JDK1.7中，新生代与老年代的默认内存占比为1:2，可通过<code>–XX:NewRatio</code>进行显式配置；年轻代中Eden区与To Survivor区、From Survivor区的比例为8:1:1，可通过<code>-XX:SurvivorRatio</code>进行显式配置</li> <li>在JDK1.8中，默认开启<code>-XX:+UseAdaptiveSizePolicy</code>配置项，将对堆中各个区域的空间大小（不再遵循以上默认值）以及进入老年代的晋升年龄进行动态调整
<ul><li>若新生代（Eden区）对象创建较多，可考虑将该配置项关闭并显式配置<code>–XX:NewRatio</code>及<code>-XX:SurvivorRatio</code>，固定Eden区空间占用比例</li></ul></li></ul> <h1 id="类加载"><a href="#类加载" class="header-anchor">#</a> 类加载</h1> <p>将类Class文件中的二进制数据读入内存，并放入运行时数据区的<strong>方法区</strong>内，然后在内存（HotSpot实现为方法区而非堆）中创建对应的Class对象</p> <ol><li><h4 id="加载"><a href="#加载" class="header-anchor">#</a> 加载</h4></li> <li><h4 id="连接"><a href="#连接" class="header-anchor">#</a> 连接</h4> <ol><li><h5 id="验证"><a href="#验证" class="header-anchor">#</a> 验证</h5></li> <li><h5 id="准备"><a href="#准备" class="header-anchor">#</a> 准备：</h5> <p>为类静态变量分配内存并赋<strong>默认值</strong></p></li> <li><h5 id="解析"><a href="#解析" class="header-anchor">#</a> 解析：</h5> <p>将类中符号饮用转换为直接引用</p></li></ol></li> <li><h4 id="初始化"><a href="#初始化" class="header-anchor">#</a> 初始化</h4> <p>为类静态变量赋<strong>初值</strong>（按照初始化语句的声明顺序执行）</p></li> <li><h4 id="类实例化"><a href="#类实例化" class="header-anchor">#</a> 类实例化</h4> <p>Java编译器为编译的每一个类都生成一个实例初始化方法（<code>&lt;init&gt;</code>方法）（对静态实例生成<code>&lt;clinit&gt;</code>静态初始化方法）</p></li></ol> <h4 id="类初始化的时机"><a href="#类初始化的时机" class="header-anchor">#</a> 类初始化的时机</h4> <h5 id="主动使用"><a href="#主动使用" class="header-anchor">#</a> 主动使用</h5> <ul><li>启动类</li> <li>创建类的实例或子类实例（子类进行初始化，前提是其所有父类都已经完成初始化过程）（<strong>这一结论不适用于接口</strong>）</li> <li>访问或修改类的静态成员变量，访问类的静态成员方法（严格区分类静态变量的定义场所，若访问子类继承而来的父类静态变量，则父类被初始化，而子类不会被初始化）</li> <li>通过反射访问类</li></ul> <h5 id="被动使用"><a href="#被动使用" class="header-anchor">#</a> 被动使用</h5> <p>创建该类型的数组或集合对象（JVM在运行时动态创建<strong>数组类型</strong>：前缀带有<code>[L</code>表示一维数组，带有<code>[[L</code>表示二维数组）</p> <p>类加载器在类可能被主动使用之前将会对其进行预先加载，如果字节码文件缺失，则只有当该类被首次主动使用时，类加载器才会报告<code>LinkageError</code>错误</p> <h3 id="类加载器"><a href="#类加载器" class="header-anchor">#</a> 类加载器</h3> <h5 id="jvm自带的类加载器"><a href="#jvm自带的类加载器" class="header-anchor">#</a> JVM自带的类加载器</h5> <ul><li>Bootstrap类加载器</li> <li>扩展类加载器</li> <li>系统（应用）类加载器</li></ul> <h5 id="用户自定义的类加载器"><a href="#用户自定义的类加载器" class="header-anchor">#</a> 用户自定义的类加载器</h5> <p><code>java.lang.ClassLoader</code>的子类</p> <h4 id="双亲委派"><a href="#双亲委派" class="header-anchor">#</a> 双亲委派</h4> <h1 id="字节码"><a href="#字节码" class="header-anchor">#</a> 字节码</h1> <h3 id="字节码结构"><a href="#字节码结构" class="header-anchor">#</a> 字节码结构</h3> <p>常量池</p> <p>方法表集合</p> <h3 id="解释与编译"><a href="#解释与编译" class="header-anchor">#</a> 解释与编译</h3> <p>默认mixed模式</p> <ul><li><code>-Xint</code></li> <li><code>-Xcomp</code></li></ul> <p>前端编译</p> <p>运行时编译</p> <blockquote><h4 id="即时-jit-编译"><a href="#即时-jit-编译" class="header-anchor">#</a> 即时（JIT）编译</h4> <h5 id="jit类型与分层编译"><a href="#jit类型与分层编译" class="header-anchor">#</a> JIT类型与分层编译</h5> <ul><li>C1</li> <li>C2</li></ul> <h5 id="jit触发时机"><a href="#jit触发时机" class="header-anchor">#</a> JIT触发时机</h5> <ul><li>方法调用计数器</li> <li>回边计数器
<ul><li>栈上替换（OSR）编译</li></ul></li></ul> <h5 id="jit常用优化策略"><a href="#jit常用优化策略" class="header-anchor">#</a> JIT常用优化策略</h5> <ul><li><p>方法内联</p> <p>JIT是否进行内联优化，与方法体大小及方法调用频率相关</p> <p><strong>在编程实践中，避免在一个方法中写大量代码，优先考虑将代码分散至多个小方法体中</strong></p></li> <li><p>逃逸分析</p> <ul><li>栈上分配（未实现❓）</li> <li>锁消除</li> <li>标量替换</li></ul></li></ul> <h5 id="aot编译器"><a href="#aot编译器" class="header-anchor">#</a> AOT编译器</h5> <h5 id="graal编译器"><a href="#graal编译器" class="header-anchor">#</a> Graal编译器</h5></blockquote> <h3 id="助记符"><a href="#助记符" class="header-anchor">#</a> 助记符</h3> <ul><li><h6 id="ldc"><a href="#ldc" class="header-anchor">#</a> <code>ldc</code></h6> <p>将<code>int</code>/<code>float</code>/<code>String</code>类型的常量值从常量池推送至（）栈顶</p> <h6 id="bipush"><a href="#bipush" class="header-anchor">#</a> <code>bipush</code></h6> <p>将<code>short</code>/<code>char</code>/<code>int</code>等单字节（-128～127）常量值从常量池推送至（）栈顶</p> <h6 id="sipush"><a href="#sipush" class="header-anchor">#</a> <code>sipush</code></h6> <p>将短整型（-32768～32767）常量值从常量池推送至（）栈顶</p> <h6 id="iconst-m1-5"><a href="#iconst-m1-5" class="header-anchor">#</a> <code>iconst_[m1-5]</code></h6> <p>将[m1-5]从常量池推送至（）栈顶</p></li> <li><h6 id="anewarray"><a href="#anewarray" class="header-anchor">#</a> <code>anewarray</code></h6> <p>创建一个引用类型（类、接口、数组）的数组，并压入栈顶</p></li></ul> <h4 id=""><a href="#" class="header-anchor">#</a></h4></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
				←
				<a href="/posts/java/concurrency.html" class="prev">
					Java并发
				</a></span> <span class="next"><a href="/posts/java/spring.html">
					Spring基础
				</a>
				→
			</span></p></div> <div class="vcomment-container" data-v-07c8026b><div id="vcomments" data-v-07c8026b></div></div> </main> <!----></div><div class="global-ui"><!----><div></div></div></div>
    <script src="/assets/js/app.9bbd0500.js" defer></script><script src="/assets/js/1.7e1accfd.js" defer></script><script src="/assets/js/13.b5619b2f.js" defer></script><script src="/assets/js/21.aad032a5.js" defer></script>
  </body>
</html>
