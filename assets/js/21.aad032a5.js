(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{622:function(a,t,v){"use strict";v.r(t);var s=v(24),_=Object(s.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"jvm内存分区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存分区"}},[a._v("#")]),a._v(" JVM内存分区")]),a._v(" "),v("h2",{attrs:{id:"pc寄存器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pc寄存器"}},[a._v("#")]),a._v(" PC寄存器")]),a._v(" "),v("h2",{attrs:{id:"栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[a._v("#")]),a._v(" 栈")]),a._v(" "),v("h3",{attrs:{id:"栈帧"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈帧"}},[a._v("#")]),a._v(" 栈帧")]),a._v(" "),v("h3",{attrs:{id:"局部变量表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#局部变量表"}},[a._v("#")]),a._v(" 局部变量表")]),a._v(" "),v("h3",{attrs:{id:"操作数栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作数栈"}},[a._v("#")]),a._v(" 操作数栈")]),a._v(" "),v("h5",{attrs:{id:"本地方法栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),v("h2",{attrs:{id:"堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),v("h3",{attrs:{id:"堆空间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆空间"}},[a._v("#")]),a._v(" 堆空间")]),a._v(" "),v("h4",{attrs:{id:"代码优化策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代码优化策略"}},[a._v("#")]),a._v(" 代码优化策略")]),a._v(" "),v("h4",{attrs:{id:"序列化与深拷贝"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#序列化与深拷贝"}},[a._v("#")]),a._v(" 序列化与深拷贝")]),a._v(" "),v("h4",{attrs:{id:"tlab"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tlab"}},[a._v("#")]),a._v(" TLAB")]),a._v(" "),v("h2",{attrs:{id:"方法区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),v("h4",{attrs:{id:"字符串常量池-全局串池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池-全局串池"}},[a._v("#")]),a._v(" 字符串常量池（全局串池）")]),a._v(" "),v("p",[a._v("JDK1.6中串池存在于"),v("strong",[a._v("方法区（永久代）"),v("strong",[a._v("中，只有当进行fullGC时才进行垃圾回收；JDK1.7中串池脱离方法区，存在于")]),a._v("堆")]),a._v("中，只要进行minorGC时就进行垃圾回收")]),a._v(" "),v("p",[a._v("类加载"),v("strong",[a._v("解析阶段")]),a._v("，在堆中生成字符串对象实例，并将该字符串对象实例的"),v("strong",[a._v("引用值")]),a._v("存于串池（JDK1.7后位于堆）中")]),a._v(" "),v("p",[a._v("HotSpot VM中的具体实现为"),v("code",[a._v("StringTable")]),a._v("（串池map），其中存储"),v("strong",[a._v("驻留字符串引用")]),a._v("，在每个HotSpot VM实例只有一份，被所有的类共享")]),a._v(" "),v("div",{staticClass:"language-java extra-class"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" a "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"a"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" b "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"b"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" ab1 "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"ab"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" ab2 "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" b"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ab2 != ab1")]),a._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" ab3 "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"a"')]),a._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"b"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ab3 == ab1")]),a._v("\n\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" abi "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" ab2"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("intern")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// abi != ab2且abi == ab1 == ab3（JDK1.7）")]),a._v("\n")])])]),v("ul",[v("li",[v("p",[a._v("字面值常量（a、b、ab1）")]),a._v(" "),v("p",[a._v("若在串池中未找到目标字符串对象，则创建对应的字符串对象存储于堆中，将其引用放入串池（整个过程为懒加载）")])]),a._v(" "),v("li",[v("p",[a._v("字符串拼接表达式（ab2、ab3）")]),a._v(" "),v("ul",[v("li",[a._v("若表达式中包含变量，创建"),v("code",[a._v("StringBuilder")]),a._v("对象，分别拼接表达式变量，最后将"),v("code",[a._v("toString()")]),a._v("结果（新字符串）保存于堆中，并将其引用赋值给ab2而"),v("strong",[a._v("不放入串池")])]),a._v(" "),v("li",[a._v("若表达式中均为常量，则在编译期进行字符串拼接，并执行字面值常量初始化流程")])])]),a._v(" "),v("li",[v("p",[v("code",[a._v("intern()")])]),a._v(" "),v("ul",[v("li",[v("strong",[a._v("JDK1.7")]),a._v("：尝试将调用该方法的字符串对象引用放入串池，并返回串池中该对象的引用\n"),v("ul",[v("li",[a._v("若串池中不存在该对象引用，则返回的对象引用 "),v("code",[a._v("==")]),a._v(" 当前对象引用")]),a._v(" "),v("li",[a._v("若串池中已存在该对象引用，则无需将当前字符串关联串池，返回的对象引用 "),v("code",[a._v("!=")]),a._v(" 当前对象引用")])])]),a._v(" "),v("li",[v("strong",[a._v("JDK1.6")]),a._v("：尝试将调用该方法的字符串对象的"),v("strong",[a._v("副本")]),a._v("引用放入串池，并返回串池中该对象引用，因此返回的对象引用 "),v("code",[a._v("!=")]),a._v(" 当前对象引用")])])])]),a._v(" "),v("h6",{attrs:{id:"串池调优"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#串池调优"}},[a._v("#")]),a._v(" 串池调优")]),a._v(" "),v("h4",{attrs:{id:"class文件常量池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#class文件常量池"}},[a._v("#")]),a._v(" class文件常量池")]),a._v(" "),v("p",[a._v("类加载阶段，编译器生成的各种字面量于符号引用存储于class文件常量池（表）中。其中在类加载"),v("strong",[a._v("解析")]),a._v("阶段，运行时常量池中符号引用被替换为直接引用，此时可能需要查询串池，以保证串池中的字符串引用值与class文件常量池中的字符串引用值一致")]),a._v(" "),v("h4",{attrs:{id:"运行时常量池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池"}},[a._v("#")]),a._v(" 运行时常量池")]),a._v(" "),v("p",[a._v("类加载阶段结束后，class文件常量池中的内容转移至运行时常量池中")]),a._v(" "),v("p",[a._v("JDK1.6中运行时常量池存在于**方法区（永久代）"),v("strong",[a._v("中，JDK1.8中运行时常量池存在于")]),a._v("元空间（直接内存）**中")]),a._v(" "),v("h1",{attrs:{id:"垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),v("h2",{attrs:{id:"基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[a._v("#")]),a._v(" 基本概念")]),a._v(" "),v("h3",{attrs:{id:"根对象与可达性分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#根对象与可达性分析"}},[a._v("#")]),a._v(" 根对象与可达性分析")]),a._v(" "),v("h6",{attrs:{id:"根对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#根对象"}},[a._v("#")]),a._v(" 根对象：")]),a._v(" "),v("ul",[v("li",[a._v("强引用")]),a._v(" "),v("li",[a._v("软引用")]),a._v(" "),v("li",[a._v("弱引用")]),a._v(" "),v("li",[a._v("虚引用")]),a._v(" "),v("li",[a._v("终结器引用")])]),a._v(" "),v("h3",{attrs:{id:"gc算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc算法"}},[a._v("#")]),a._v(" GC算法")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("标记-清除")]),a._v(" "),v("ol",[v("li",[a._v("标记可达对象")]),a._v(" "),v("li",[a._v("清除不可达对象")])]),a._v(" "),v("h6",{attrs:{id:"缺陷"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺陷"}},[a._v("#")]),a._v(" 缺陷")]),a._v(" "),v("ul",[v("li",[a._v("STW较长，性能较差")]),a._v(" "),v("li",[a._v("碎片化严重")])])]),a._v(" "),v("li",[v("p",[a._v("标记-整理")])]),a._v(" "),v("li",[v("p",[a._v("复制")]),a._v(" "),v("h6",{attrs:{id:"缺陷-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺陷-2"}},[a._v("#")]),a._v(" 缺陷")]),a._v(" "),v("ul",[v("li",[a._v("存货对象较多时影响性能（故不适用于老年代）")]),a._v(" "),v("li",[a._v("只使用一半空间进行对象填充，内存使用率较低")])])]),a._v(" "),v("li",[v("p",[a._v("分代收集（新生代使用"),v("strong",[a._v("复制算法")]),a._v("，老年代使用标记-清除/标记-整理算法）")])])]),a._v(" "),v("h3",{attrs:{id:"gc类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc类型"}},[a._v("#")]),a._v(" GC类型")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("MinorGC")]),a._v(" "),v("p",[a._v("新生代满时触发")]),a._v(" "),v("blockquote",[v("p",[a._v("以下对象将提前晋升至老年代：")]),a._v(" "),v("ul",[v("li",[a._v("长期存活的对象")]),a._v(" "),v("li",[a._v("Survivor区无法容纳的大对象")]),a._v(" "),v("li",[a._v("Survivor区可容纳，但复制过程过于消耗性能的大对象")])])])]),a._v(" "),v("li",[v("p",[a._v("FullGC")]),a._v(" "),v("p",[a._v("老年代满时触发")])]),a._v(" "),v("li",[v("p",[a._v("OOM：某线程发生OOM将清空其占用的堆内存，而不影响其他线程")])])]),a._v(" "),v("h2",{attrs:{id:"垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器"}},[a._v("#")]),a._v(" 垃圾回收器")]),a._v(" "),v("h4",{attrs:{id:"串行-不推荐使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#串行-不推荐使用"}},[a._v("#")]),a._v(" 串行（不推荐使用）")]),a._v(" "),v("p",[v("code",[a._v("-XX:+UseSerialGC")]),a._v("：Serial New（新生代，"),v("strong",[a._v("复制")]),a._v("） + Serial Old（老年代，"),v("strong",[a._v("标记-清除")]),a._v("）")]),a._v(" "),v("h4",{attrs:{id:"并行-jdk6、7、8默认"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并行-jdk6、7、8默认"}},[a._v("#")]),a._v(" 并行（JDK6、7、8默认）")]),a._v(" "),v("p",[v("code",[a._v("-XX:+UseParallelGC")]),a._v("/"),v("code",[a._v("-XX:+UseParallelOldGC")]),a._v("：Parallel Scavenge（新生代+老年代，"),v("strong",[a._v("复制")]),a._v("）")]),a._v(" "),v("p",[a._v("吞吐量优先，"),v("strong",[a._v("GC线程")]),a._v("对CPU占用高")]),a._v(" "),v("p",[v("code",[a._v("-XX:GCTimeRatio=GC时间占总吞吐时间百分比")]),a._v("（默认值99%）")]),a._v(" "),v("p",[v("code",[a._v("-XX:MaxGCPauseMillis=GC最大STW时间")])]),a._v(" "),v("h4",{attrs:{id:"cms-并发-jdk9废弃"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cms-并发-jdk9废弃"}},[a._v("#")]),a._v(" CMS（并发，JDK9废弃）")]),a._v(" "),v("p",[v("code",[a._v("-XX:+UseConcMarkSweepGC")]),a._v("：CMS（老年代，"),v("strong",[a._v("标记-清除")]),a._v("；ParNew Old为备用）+ "),v("code",[a._v("-XX:+UseParNewGC")]),a._v("：ParNew New（【并行】新生代，"),v("strong",[a._v("复制")]),a._v("）")]),a._v(" "),v("blockquote",[v("ol",[v("li",[a._v("初始标记（STW）")]),a._v(" "),v("li",[a._v("并发标记")]),a._v(" "),v("li",[a._v("预清理")]),a._v(" "),v("li",[a._v("重新标记（STW）")]),a._v(" "),v("li",[a._v("并发清理")]),a._v(" "),v("li",[a._v("并发重置")])])]),a._v(" "),v("p",[a._v("响应时间优先，"),v("strong",[a._v("GC线程")]),a._v("对CPU占用低")]),a._v(" "),v("p",[a._v("若并发GC失败，则CMS退化为SerialOld")]),a._v(" "),v("p",[v("code",[a._v("-XX:ParallelGCThreads=并行线程（工作线程）数")])]),a._v(" "),v("p",[v("code",[a._v("-XX:ConcGCThreads=并发线程（GC线程）数")]),a._v("（t2 = t1 / 4）")]),a._v(" "),v("p",[v("code",[a._v("-XX:CMSInitiatingOccupancyFraction")]),a._v("当老年代浮动垃圾占比达到该值时，开始执行FullGC")]),a._v(" "),v("p",[v("code",[a._v("-XX:+CMSScavengeBeforeRemark")]),a._v("执行FullGC前先使用ParNewGC对新生代进行清理，减少老年代对新生代的引用，降低重新标记阶段的资源开销")]),a._v(" "),v("p",[v("code",[a._v("-XX:UseCMSCompactAtFullCollection")]),a._v("+"),v("code",[a._v("-XX:CMSFullGCsBeforeCompaction")]),a._v("在执行FullGC之后进行老年代内存压缩，降低内存碎片出现频率")]),a._v(" "),v("h4",{attrs:{id:"g1-jdk9默认"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#g1-jdk9默认"}},[a._v("#")]),a._v(" G1（JDK9默认）")]),a._v(" "),v("p",[v("code",[a._v("-XX:+UseG1GC")]),a._v(" ：G1（"),v("strong",[a._v("区域间复制")]),a._v(" + "),v("strong",[a._v("标记-整理")]),a._v("）")]),a._v(" "),v("h5",{attrs:{id:"回收原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回收原理"}},[a._v("#")]),a._v(" 回收原理")]),a._v(" "),v("h6",{attrs:{id:"堆内存分区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆内存分区"}},[a._v("#")]),a._v(" 堆内存分区")]),a._v(" "),v("p",[a._v("在进行区域间复制的过程中，同时实现了标记-整理功能，降低内存碎片化概率")]),a._v(" "),v("ul",[v("li",[a._v("Humongous区（巨型对象区）")])]),a._v(" "),v("h6",{attrs:{id:"回收流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回收流程"}},[a._v("#")]),a._v(" 回收流程")]),a._v(" "),v("blockquote",[v("h5",{attrs:{id:"stw"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#stw"}},[a._v("#")]),a._v(" STW")]),a._v(" "),v("p",[v("code",[a._v("-XX:MaxGCPauseMillis")])]),a._v(" "),v("p",[a._v("默认STW时间为200ms")])]),a._v(" "),v("ol",[v("li",[v("h6",{attrs:{id:"young-collection"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#young-collection"}},[a._v("#")]),a._v(" Young Collection")]),a._v(" "),v("blockquote",[v("h6",{attrs:{id:"跨代引用、remembered-set与卡表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#跨代引用、remembered-set与卡表"}},[a._v("#")]),a._v(" 跨代引用、"),v("code",[a._v("Remembered Set")]),a._v("与卡表")])])]),a._v(" "),v("li",[v("h6",{attrs:{id:"mixed-collection"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mixed-collection"}},[a._v("#")]),a._v(" Mixed Collection")]),a._v(" "),v("p",[a._v("触发时机控制："),v("code",[a._v("-XX:InitiatingHeapOccupancyPercent")]),a._v("（默认值45%）")]),a._v(" "),v("ol",[v("li",[a._v("初始标记（STW）")]),a._v(" "),v("li",[a._v("根区域扫描")]),a._v(" "),v("li",[a._v("并发标记（STW）")]),a._v(" "),v("li",[a._v("最终标记（STW）")]),a._v(" "),v("li",[a._v("拷贝存活（Evacuation（STW）：老年代垃圾进行选择性回收，优先回收巨型对象）")])])])]),a._v(" "),v("blockquote",[v("h5",{attrs:{id:"pre-write-barrier与satb-mark-queue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pre-write-barrier与satb-mark-queue"}},[a._v("#")]),a._v(" "),v("code",[a._v("pre-write barrier")]),a._v("与"),v("code",[a._v("satb_mark_queue")])])]),a._v(" "),v("ul",[v("li",[v("h4",{attrs:{id:"zgc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#zgc"}},[a._v("#")]),a._v(" ZGC")])]),a._v(" "),v("li",[v("h4",{attrs:{id:"epsilon、shenandoah"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#epsilon、shenandoah"}},[a._v("#")]),a._v(" Epsilon、Shenandoah")])])]),a._v(" "),v("h3",{attrs:{id:"gc性能衡量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc性能衡量"}},[a._v("#")]),a._v(" GC性能衡量")]),a._v(" "),v("h4",{attrs:{id:"衡量指标"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#衡量指标"}},[a._v("#")]),a._v(" 衡量指标")]),a._v(" "),v("h5",{attrs:{id:"吞吐量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#吞吐量"}},[a._v("#")]),a._v(" 吞吐量")]),a._v(" "),v("p",[a._v("$\\Huge{\\frac{GC耗时}{应用程序耗时 + GC耗时}}$")]),a._v(" "),v("h5",{attrs:{id:"停顿时间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#停顿时间"}},[a._v("#")]),a._v(" 停顿时间")]),a._v(" "),v("h5",{attrs:{id:"gc频率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc频率"}},[a._v("#")]),a._v(" GC频率")]),a._v(" "),v("h4",{attrs:{id:"衡量工具"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#衡量工具"}},[a._v("#")]),a._v(" 衡量工具")]),a._v(" "),v("p",[a._v("**"),v("code",[a._v("top")]),a._v("**查看进程的内存使用情况")]),a._v(" "),v("h6",{attrs:{id:"jstack"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jstack"}},[a._v("#")]),a._v(" "),v("code",[a._v("jstack")])]),a._v(" "),v("p",[a._v("​\t"),v("code",[a._v("jstack [PID]")]),a._v("查看具体线程的堆栈与状态信息")]),a._v(" "),v("h6",{attrs:{id:"jstat"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jstat"}},[a._v("#")]),a._v(" "),v("code",[a._v("jstat")])]),a._v(" "),v("p",[a._v("​\t"),v("code",[a._v("jstat -class [PID]")]),a._v("/"),v("code",[a._v("jstat -compiler [PID]")]),a._v("查看类加载/类编译的数量")]),a._v(" "),v("p",[a._v("​\t"),v("code",[a._v("jstat -gc [PID] [打印间隔/ms] [打印次数]")]),a._v("查看堆中各个分区的内存占用情况及GC情况")]),a._v(" "),v("h6",{attrs:{id:"jmap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jmap"}},[a._v("#")]),a._v(" "),v("code",[a._v("jmap")])]),a._v(" "),v("p",[a._v("​\t"),v("code",[a._v("jmap -heap [PID]")]),a._v("查看堆中各个分区的内存占用情况，以及所用垃圾收集器的设置类型")]),a._v(" "),v("p",[a._v("​\t"),v("code",[a._v("jmap -histo[:live] [PID] | more")]),a._v("查看堆内存中的对象数目、大小统计直方图")]),a._v(" "),v("p",[a._v("​\t"),v("code",[a._v("jmap -dump:format=b,file=./heap.hprof [PID]")]),a._v("输出堆dump文件结合jhat/MAT进行分析")]),a._v(" "),v("p",[a._v("​\t\t"),v("code",[a._v("-XX:HeapDumpOnOutOfMemoryError")]),a._v("在发生 OOM 时输出堆dump文件")]),a._v(" "),v("h6",{attrs:{id:"jhat"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jhat"}},[a._v("#")]),a._v(" "),v("code",[a._v("jhat")])]),a._v(" "),v("p",[a._v("​\t"),v("code",[a._v("jhat -port [PORT] ./heap.hprof")])]),a._v(" "),v("h6",{attrs:{id:"jinfo"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jinfo"}},[a._v("#")]),a._v(" "),v("code",[a._v("jinfo")])]),a._v(" "),v("p",[a._v("​\t"),v("code",[a._v("jinfo -flags [PID]")])]),a._v(" "),v("h1",{attrs:{id:"调优"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调优"}},[a._v("#")]),a._v(" ==调优==")]),a._v(" "),v("h2",{attrs:{id:"gc调优"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc调优"}},[a._v("#")]),a._v(" GC调优")]),a._v(" "),v("div",{staticClass:"language-bash extra-class"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[a._v("-XX:+PrintGC 输出 GC 日志\n-XX:+PrintGCDetails 输出 GC 的详细日志\n-XX:+PrintGCTimeStamps 输出 GC 的时间戳"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("以基准时间的形式"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n-XX:+PrintGCDateStamps 输出 GC 的时间戳"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("以日期的形式，如 "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("2013")]),a._v("-05-04T21:53:59.234+0800"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n-XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息\n-Xloggc:"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("/logs/gc.log 日志文件的输出路径\n")])])]),v("p",[a._v("可使用GC Viewer/GC Easy等工具对输出的GC日志文件进行分析，根据分析结果进行内存与GC调优")]),a._v(" "),v("h3",{attrs:{id:"堆-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆-2"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),v("p",[a._v("无用对象的回收")]),a._v(" "),v("p",[v("code",[a._v("-XX:MaxTenuringThreshold")]),a._v("新生代对象晋升年龄阈值（最大值15）")]),a._v(" "),v("p",[v("code",[a._v("-XX:PretenureSizeThreshold")]),a._v(" 新生代对象直接晋升大小阈值")]),a._v(" "),v("h5",{attrs:{id:"降低minor-gc频率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#降低minor-gc频率"}},[a._v("#")]),a._v(" 降低Minor GC频率")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("通过进一步增加新生代内存以降低Minor GC频率")]),a._v(" "),v("p",[a._v("若新生代对象存活时间普遍较长，则不可贸然增加新生代内存，否则反而会增加Minor GC时间")])])]),a._v(" "),v("h5",{attrs:{id:"降低full-gc频率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#降低full-gc频率"}},[a._v("#")]),a._v(" 降低Full GC频率")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("若新生代Surviver区内存紧张，则对象晋升年龄/大小可能降低（"),v("code",[a._v("-XX:+UseAdaptiveSizePolicy")]),a._v("），增大老年代Full GC概率")]),a._v(" "),v("p",[a._v("故可通过"),v("strong",[a._v("适当增大堆内存空间，提高新生代对象晋升年龄与大小阈值")]),a._v("进行缓解")])])]),a._v(" "),v("h3",{attrs:{id:"方法区-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法区-2"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),v("p",[a._v("无用常量与类的回收")]),a._v(" "),v("h2",{attrs:{id:"内存调优"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存调优"}},[a._v("#")]),a._v(" 内存调优")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("-Xms")]),a._v("与"),v("code",[a._v("-Xmx")]),a._v("建议配置相同的值，使得在GC后无需重新分隔计算堆区的大小")]),a._v(" "),v("li",[v("code",[a._v("-Xmn")]),a._v("新生代内存分配一般为堆内存空间的25%～50%（Sun推荐配置为整个堆内存大小的3/8）")]),a._v(" "),v("li",[a._v("在JDK1.7中，新生代与老年代的默认内存占比为1:2，可通过"),v("code",[a._v("–XX:NewRatio")]),a._v("进行显式配置；年轻代中Eden区与To Survivor区、From Survivor区的比例为8:1:1，可通过"),v("code",[a._v("-XX:SurvivorRatio")]),a._v("进行显式配置")]),a._v(" "),v("li",[a._v("在JDK1.8中，默认开启"),v("code",[a._v("-XX:+UseAdaptiveSizePolicy")]),a._v("配置项，将对堆中各个区域的空间大小（不再遵循以上默认值）以及进入老年代的晋升年龄进行动态调整\n"),v("ul",[v("li",[a._v("若新生代（Eden区）对象创建较多，可考虑将该配置项关闭并显式配置"),v("code",[a._v("–XX:NewRatio")]),a._v("及"),v("code",[a._v("-XX:SurvivorRatio")]),a._v("，固定Eden区空间占用比例")])])])]),a._v(" "),v("h1",{attrs:{id:"类加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载"}},[a._v("#")]),a._v(" 类加载")]),a._v(" "),v("p",[a._v("将类Class文件中的二进制数据读入内存，并放入运行时数据区的"),v("strong",[a._v("方法区")]),a._v("内，然后在内存（HotSpot实现为方法区而非堆）中创建对应的Class对象")]),a._v(" "),v("ol",[v("li",[v("h4",{attrs:{id:"加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#加载"}},[a._v("#")]),a._v(" 加载")])]),a._v(" "),v("li",[v("h4",{attrs:{id:"连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#连接"}},[a._v("#")]),a._v(" 连接")]),a._v(" "),v("ol",[v("li",[v("h5",{attrs:{id:"验证"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#验证"}},[a._v("#")]),a._v(" 验证")])]),a._v(" "),v("li",[v("h5",{attrs:{id:"准备"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#准备"}},[a._v("#")]),a._v(" 准备：")]),a._v(" "),v("p",[a._v("为类静态变量分配内存并赋"),v("strong",[a._v("默认值")])])]),a._v(" "),v("li",[v("h5",{attrs:{id:"解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解析"}},[a._v("#")]),a._v(" 解析：")]),a._v(" "),v("p",[a._v("将类中符号饮用转换为直接引用")])])])]),a._v(" "),v("li",[v("h4",{attrs:{id:"初始化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[a._v("#")]),a._v(" 初始化")]),a._v(" "),v("p",[a._v("为类静态变量赋"),v("strong",[a._v("初值")]),a._v("（按照初始化语句的声明顺序执行）")])]),a._v(" "),v("li",[v("h4",{attrs:{id:"类实例化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类实例化"}},[a._v("#")]),a._v(" 类实例化")]),a._v(" "),v("p",[a._v("Java编译器为编译的每一个类都生成一个实例初始化方法（"),v("code",[a._v("<init>")]),a._v("方法）（对静态实例生成"),v("code",[a._v("<clinit>")]),a._v("静态初始化方法）")])])]),a._v(" "),v("h4",{attrs:{id:"类初始化的时机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类初始化的时机"}},[a._v("#")]),a._v(" 类初始化的时机")]),a._v(" "),v("h5",{attrs:{id:"主动使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主动使用"}},[a._v("#")]),a._v(" 主动使用")]),a._v(" "),v("ul",[v("li",[a._v("启动类")]),a._v(" "),v("li",[a._v("创建类的实例或子类实例（子类进行初始化，前提是其所有父类都已经完成初始化过程）（"),v("strong",[a._v("这一结论不适用于接口")]),a._v("）")]),a._v(" "),v("li",[a._v("访问或修改类的静态成员变量，访问类的静态成员方法（严格区分类静态变量的定义场所，若访问子类继承而来的父类静态变量，则父类被初始化，而子类不会被初始化）")]),a._v(" "),v("li",[a._v("通过反射访问类")])]),a._v(" "),v("h5",{attrs:{id:"被动使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#被动使用"}},[a._v("#")]),a._v(" 被动使用")]),a._v(" "),v("p",[a._v("创建该类型的数组或集合对象（JVM在运行时动态创建"),v("strong",[a._v("数组类型")]),a._v("：前缀带有"),v("code",[a._v("[L")]),a._v("表示一维数组，带有"),v("code",[a._v("[[L")]),a._v("表示二维数组）")]),a._v(" "),v("p",[a._v("类加载器在类可能被主动使用之前将会对其进行预先加载，如果字节码文件缺失，则只有当该类被首次主动使用时，类加载器才会报告"),v("code",[a._v("LinkageError")]),a._v("错误")]),a._v(" "),v("h3",{attrs:{id:"类加载器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器")]),a._v(" "),v("h5",{attrs:{id:"jvm自带的类加载器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm自带的类加载器"}},[a._v("#")]),a._v(" JVM自带的类加载器")]),a._v(" "),v("ul",[v("li",[a._v("Bootstrap类加载器")]),a._v(" "),v("li",[a._v("扩展类加载器")]),a._v(" "),v("li",[a._v("系统（应用）类加载器")])]),a._v(" "),v("h5",{attrs:{id:"用户自定义的类加载器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户自定义的类加载器"}},[a._v("#")]),a._v(" 用户自定义的类加载器")]),a._v(" "),v("p",[v("code",[a._v("java.lang.ClassLoader")]),a._v("的子类")]),a._v(" "),v("h4",{attrs:{id:"双亲委派"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派"}},[a._v("#")]),a._v(" 双亲委派")]),a._v(" "),v("h1",{attrs:{id:"字节码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字节码"}},[a._v("#")]),a._v(" 字节码")]),a._v(" "),v("h3",{attrs:{id:"字节码结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字节码结构"}},[a._v("#")]),a._v(" 字节码结构")]),a._v(" "),v("p",[a._v("常量池")]),a._v(" "),v("p",[a._v("方法表集合")]),a._v(" "),v("h3",{attrs:{id:"解释与编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解释与编译"}},[a._v("#")]),a._v(" 解释与编译")]),a._v(" "),v("p",[a._v("默认mixed模式")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("-Xint")])]),a._v(" "),v("li",[v("code",[a._v("-Xcomp")])])]),a._v(" "),v("p",[a._v("前端编译")]),a._v(" "),v("p",[a._v("运行时编译")]),a._v(" "),v("blockquote",[v("h4",{attrs:{id:"即时-jit-编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#即时-jit-编译"}},[a._v("#")]),a._v(" 即时（JIT）编译")]),a._v(" "),v("h5",{attrs:{id:"jit类型与分层编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jit类型与分层编译"}},[a._v("#")]),a._v(" JIT类型与分层编译")]),a._v(" "),v("ul",[v("li",[a._v("C1")]),a._v(" "),v("li",[a._v("C2")])]),a._v(" "),v("h5",{attrs:{id:"jit触发时机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jit触发时机"}},[a._v("#")]),a._v(" JIT触发时机")]),a._v(" "),v("ul",[v("li",[a._v("方法调用计数器")]),a._v(" "),v("li",[a._v("回边计数器\n"),v("ul",[v("li",[a._v("栈上替换（OSR）编译")])])])]),a._v(" "),v("h5",{attrs:{id:"jit常用优化策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jit常用优化策略"}},[a._v("#")]),a._v(" JIT常用优化策略")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("方法内联")]),a._v(" "),v("p",[a._v("JIT是否进行内联优化，与方法体大小及方法调用频率相关")]),a._v(" "),v("p",[v("strong",[a._v("在编程实践中，避免在一个方法中写大量代码，优先考虑将代码分散至多个小方法体中")])])]),a._v(" "),v("li",[v("p",[a._v("逃逸分析")]),a._v(" "),v("ul",[v("li",[a._v("栈上分配（未实现❓）")]),a._v(" "),v("li",[a._v("锁消除")]),a._v(" "),v("li",[a._v("标量替换")])])])]),a._v(" "),v("h5",{attrs:{id:"aot编译器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aot编译器"}},[a._v("#")]),a._v(" AOT编译器")]),a._v(" "),v("h5",{attrs:{id:"graal编译器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#graal编译器"}},[a._v("#")]),a._v(" Graal编译器")])]),a._v(" "),v("h3",{attrs:{id:"助记符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#助记符"}},[a._v("#")]),a._v(" 助记符")]),a._v(" "),v("ul",[v("li",[v("h6",{attrs:{id:"ldc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ldc"}},[a._v("#")]),a._v(" "),v("code",[a._v("ldc")])]),a._v(" "),v("p",[a._v("将"),v("code",[a._v("int")]),a._v("/"),v("code",[a._v("float")]),a._v("/"),v("code",[a._v("String")]),a._v("类型的常量值从常量池推送至（）栈顶")]),a._v(" "),v("h6",{attrs:{id:"bipush"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bipush"}},[a._v("#")]),a._v(" "),v("code",[a._v("bipush")])]),a._v(" "),v("p",[a._v("将"),v("code",[a._v("short")]),a._v("/"),v("code",[a._v("char")]),a._v("/"),v("code",[a._v("int")]),a._v("等单字节（-128～127）常量值从常量池推送至（）栈顶")]),a._v(" "),v("h6",{attrs:{id:"sipush"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sipush"}},[a._v("#")]),a._v(" "),v("code",[a._v("sipush")])]),a._v(" "),v("p",[a._v("将短整型（-32768～32767）常量值从常量池推送至（）栈顶")]),a._v(" "),v("h6",{attrs:{id:"iconst-m1-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#iconst-m1-5"}},[a._v("#")]),a._v(" "),v("code",[a._v("iconst_[m1-5]")])]),a._v(" "),v("p",[a._v("将[m1-5]从常量池推送至（）栈顶")])]),a._v(" "),v("li",[v("h6",{attrs:{id:"anewarray"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#anewarray"}},[a._v("#")]),a._v(" "),v("code",[a._v("anewarray")])]),a._v(" "),v("p",[a._v("创建一个引用类型（类、接口、数组）的数组，并压入栈顶")])])]),a._v(" "),v("h4",{attrs:{id:""}},[v("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")])])])}),[],!1,null,null,null);t.default=_.exports}}]);