<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java并发 | Felix Mundial的杂烩图书馆</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/icons/favicon.png">
    <meta name="description" content="github page powered by Vuepress">
    
    <link rel="preload" href="/assets/css/0.styles.0e3647e7.css" as="style"><link rel="preload" href="/assets/js/app.9bbd0500.js" as="script"><link rel="preload" href="/assets/js/1.7e1accfd.js" as="script"><link rel="preload" href="/assets/js/13.b5619b2f.js" as="script"><link rel="preload" href="/assets/js/7.b57f400b.js" as="script"><link rel="prefetch" href="/assets/js/10.535b18bf.js"><link rel="prefetch" href="/assets/js/11.9f4c7505.js"><link rel="prefetch" href="/assets/js/12.1040a13c.js"><link rel="prefetch" href="/assets/js/14.9065f59b.js"><link rel="prefetch" href="/assets/js/15.1af3a730.js"><link rel="prefetch" href="/assets/js/16.145ee41f.js"><link rel="prefetch" href="/assets/js/17.daef2d0a.js"><link rel="prefetch" href="/assets/js/18.ccf124a3.js"><link rel="prefetch" href="/assets/js/19.3c9e19e5.js"><link rel="prefetch" href="/assets/js/20.cbce51c7.js"><link rel="prefetch" href="/assets/js/21.aad032a5.js"><link rel="prefetch" href="/assets/js/22.d26d3f4d.js"><link rel="prefetch" href="/assets/js/23.36d5eb9b.js"><link rel="prefetch" href="/assets/js/24.3d224717.js"><link rel="prefetch" href="/assets/js/25.e67e5f2e.js"><link rel="prefetch" href="/assets/js/26.26226ddd.js"><link rel="prefetch" href="/assets/js/27.ef309e27.js"><link rel="prefetch" href="/assets/js/28.275159e4.js"><link rel="prefetch" href="/assets/js/29.f7f84fc3.js"><link rel="prefetch" href="/assets/js/3.92bf9476.js"><link rel="prefetch" href="/assets/js/4.7de240dc.js"><link rel="prefetch" href="/assets/js/5.422f2530.js"><link rel="prefetch" href="/assets/js/6.9952df18.js"><link rel="prefetch" href="/assets/js/8.a18e3f05.js"><link rel="prefetch" href="/assets/js/9.c6f1e43f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0e3647e7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="azure" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name"><i class="el-icon-bicycle"></i> Felix Mundial的杂烩图书馆</span></a> <div class="links"><nav class="nav-links can-hide"><div class="nav-item"><a href="/guide/toc.html" class="nav-link" data-v-c7dec8ac><i class="el-icon-discount"></i> Archives</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/leetcode/leetcode101.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-leetcode"></i> Leetcode</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-java"></i> Java</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/java/concurrency.html" aria-current="page" class="nav-link router-link-exact-active router-link-active" data-v-c7dec8ac>并发</a></li><li class="dropdown-item"><!----> <a href="/posts/java/jvm.html" class="nav-link" data-v-c7dec8ac>JVM</a></li><li class="dropdown-item"><!----> <a href="/posts/java/spring.html" class="nav-link" data-v-c7dec8ac>Spring</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springmvc.html" class="nav-link" data-v-c7dec8ac>Spring MVC</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springboot.html" class="nav-link" data-v-c7dec8ac>Spring Boot</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-database"></i> 数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/database/mysql.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-mysql"></i> MySQL</a></li><li class="dropdown-item"><!----> <a href="/posts/database/redis.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-redis"></i> Redis</a></li></ul></div></div> <!----></nav> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/guide/toc.html" class="nav-link" data-v-c7dec8ac><i class="el-icon-discount"></i> Archives</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/leetcode/leetcode101.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-leetcode"></i> Leetcode</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-java"></i> Java</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/java/concurrency.html" aria-current="page" class="nav-link router-link-exact-active router-link-active" data-v-c7dec8ac>并发</a></li><li class="dropdown-item"><!----> <a href="/posts/java/jvm.html" class="nav-link" data-v-c7dec8ac>JVM</a></li><li class="dropdown-item"><!----> <a href="/posts/java/spring.html" class="nav-link" data-v-c7dec8ac>Spring</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springmvc.html" class="nav-link" data-v-c7dec8ac>Spring MVC</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springboot.html" class="nav-link" data-v-c7dec8ac>Spring Boot</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-database"></i> 数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/database/mysql.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-mysql"></i> MySQL</a></li><li class="dropdown-item"><!----> <a href="/posts/database/redis.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-redis"></i> Redis</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/java/concurrency.html" aria-current="page" class="active sidebar-link">Java并发</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/java/concurrency.html#synchronized" class="sidebar-link">synchronized</a></li><li class="sidebar-sub-header"><a href="/posts/java/concurrency.html#线程等待与通知" class="sidebar-link">线程等待与通知</a></li><li class="sidebar-sub-header"><a href="/posts/java/concurrency.html#lock锁-java-util-concurrent-locks" class="sidebar-link">Lock锁（java.util.concurrent.locks.*）</a></li><li class="sidebar-sub-header"><a href="/posts/java/concurrency.html#cas" class="sidebar-link">CAS</a></li><li class="sidebar-sub-header"><a href="/posts/java/concurrency.html#可见性-读同步问题" class="sidebar-link">可见性（读同步问题）</a></li><li class="sidebar-sub-header"><a href="/posts/java/concurrency.html#原子性-写同步问题" class="sidebar-link">原子性（写同步问题）</a></li><li class="sidebar-sub-header"><a href="/posts/java/concurrency.html#hashtable-vector" class="sidebar-link">HashTable/Vector</a></li><li class="sidebar-sub-header"><a href="/posts/java/concurrency.html#collections-synchronized" class="sidebar-link">Collections.Synchronized*</a></li><li class="sidebar-sub-header"><a href="/posts/java/concurrency.html#blocking" class="sidebar-link">Blocking*</a></li><li class="sidebar-sub-header"><a href="/posts/java/concurrency.html#copyonwrite" class="sidebar-link">CopyOnWrite*</a></li><li class="sidebar-sub-header"><a href="/posts/java/concurrency.html#concurrent" class="sidebar-link">Concurrent*</a></li></ul></li><li><a href="/posts/java/jvm.html" class="sidebar-link">JVM</a></li><li><a href="/posts/java/spring.html" class="sidebar-link">Spring基础</a></li><li><a href="/posts/java/springboot.html" class="sidebar-link">Spring Boot基础</a></li><li><a href="/posts/java/springmvc.html" class="sidebar-link">Spring MVC基础</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="post-header" data-v-528c0c8a><h2 class="post-title" data-v-528c0c8a><a href="/posts/java/concurrency.html" data-v-528c0c8a><!---->
			Java并发
		</a></h2> <div class="post-meta" data-v-528c0c8a><div class="author post-meta-item" data-v-528c0c8a><i class="el-icon-bicycle" data-v-528c0c8a></i> <span data-v-528c0c8a>FelixMundial</span></div> <div class="time post-meta-item" data-v-528c0c8a><i class="el-icon-time" data-v-528c0c8a></i> <time data-v-528c0c8a>2020-11-18</time></div> <div class="category post-meta-item" data-v-528c0c8a><i class="el-icon-collection" data-v-528c0c8a></i> <a href="/category/并发" class="category-item" data-v-528c0c8a>
				并发
			</a></div> <div class="tags post-meta-item" data-v-528c0c8a><i class="el-icon-price-tag" data-v-528c0c8a></i> <span class="tag-item el-tag el-tag--light" data-v-528c0c8a>
				JavaSE
			</span><span class="tag-item el-tag el-tag--light" data-v-528c0c8a>
				并发
			</span></div> <div id="/posts/java/concurrency.html" data-flag-title="Java并发" class="leancloud-visitors post-meta-item" data-v-528c0c8a><i class="el-icon-reading" data-v-528c0c8a></i> <span class="leancloud-visitors-count" data-v-528c0c8a>0</span></div></div></div> <div class="theme-default-content content__default"><h1 id="基础api"><a href="#基础api" class="header-anchor">#</a> 基础API</h1> <h6 id="thread-sleep"><a href="#thread-sleep" class="header-anchor">#</a> <code>Thread.sleep()</code></h6> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此处可避免<code>while() {}</code>循环空转消耗cpu性能，使用<code>sleep()</code>或<code>yield()</code>适当让出cpu使用权</p> <blockquote><p>适用于无须锁同步的场景</p></blockquote> <h6 id="thread1-join"><a href="#thread1-join" class="header-anchor">#</a> <code>&lt;thread1&gt;.join()</code></h6> <p>调用线程进行阻塞，同步等待thread1执行结束</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Thread</span> t1<span class="token punctuation">;</span> <span class="token comment">// 休眠1s</span>
<span class="token class-name">Thread</span> t2<span class="token punctuation">;</span> <span class="token comment">// 休眠2s</span>

t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只需额外等待1s（两线程与主线程同时开始执行，主线程分别只对两线程的结束时机进行同步等待）</span>
</code></pre></div><h6 id="thread1-interrupt"><a href="#thread1-interrupt" class="header-anchor">#</a> <code>&lt;thread1&gt;.interrupt()</code></h6> <ol><li>正常运行的线程被打断后，打断标记<code>isInterrupted()</code>为<code>true</code>（意味着可通过该标记进行后续处理）</li> <li>通过调用<code>sleep()</code>、<code>wait()</code>、<code>join()</code>等方法处于阻塞状态的线程被打断后，打断标记将被自动清空，置为<code>false</code>（意味着线程已进入异常，该标记已失去作用，可在<code>catch</code>块中重新设置标记为<code>true</code>）</li> <li>通过调用<code>park()</code>方法处于阻塞状态的线程被打断后，打断标记为<code>true</code>；若不手动重置该标记为<code>false</code>（静态方法<code>Thread.interrupt()</code>），则后续的<code>park()</code>操作均会失效</li></ol> <blockquote><p><strong>二阶段终止模式</strong>实现监控流程</p> <div class="language-mermaid extra-class"><pre class="language-text"><code>graph TD
w(&quot;while(true)&quot;) --&gt; a
a(&quot;isInterrupted()&quot;) -- true --&gt; b(&quot;释放资源&quot;)
b --&gt; c(&quot;结束循环&quot;)
a -- false --&gt; d(&quot;sleep()&quot;)
d -- 无异常 --&gt; e(&quot;执行监控业务&quot;)
d -- 出现异常 --&gt; i(&quot;设置打断标记&quot;)
i --&gt; w
e --&gt; w
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TwoPhaseTermination</span> <span class="token punctuation">{</span>
  	<span class="token keyword">private</span> <span class="token class-name">Thread</span> monitor<span class="token punctuation">;</span>
  
  	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   		monitor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
     		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        		<span class="token class-name">Thread</span> currentThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        		<span class="token keyword">if</span> <span class="token punctuation">(</span>currentThread<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          		<span class="token comment">/*
          		释放资源
          		*/</span>
          		<span class="token keyword">break</span><span class="token punctuation">;</span>
        		<span class="token punctuation">}</span>
        
        		<span class="token keyword">try</span> <span class="token punctuation">{</span>
          		<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          		<span class="token comment">/*
          		执行监控业务
          		*/</span>
        		<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          		currentThread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻塞过程中被打断，需手动再次设置打断标记（重新打断）</span>
        		<span class="token punctuation">}</span>
      		<span class="token punctuation">}</span>
    		<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    		monitor<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token punctuation">}</span>
  
  	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stopMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		monitor<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote> <h1 id="共享内存模型-管程-悲观锁-阻塞式"><a href="#共享内存模型-管程-悲观锁-阻塞式" class="header-anchor">#</a> 共享内存模型：管程（悲观锁，阻塞式）</h1> <p>避免临界区竞态条件发生的多种方式</p> <h2 id="synchronized"><a href="#synchronized" class="header-anchor">#</a> <code>synchronized</code></h2> <blockquote><ul><li>通过<strong>对象锁</strong>保证临界区内代码的原子性</li> <li><code>synchronized</code>锁为可重入锁</li> <li>对象模型：
<ul><li>重入计数器❓</li> <li>Contention List</li> <li>Entry List</li> <li>Wait Set</li> <li>On Deck</li></ul></li></ul></blockquote> <h3 id="局部变量和共享变量的线程安全问题"><a href="#局部变量和共享变量的线程安全问题" class="header-anchor">#</a> 局部变量和共享变量的线程安全问题</h3> <ul><li><strong>不同线程对共享变量进行并发增删引发线程安全问题；而对于局部变量，不同线程分别拥有一份自己的局部变量实例，此时不引发线程安全问题</strong></li> <li>若在<strong>父类public方法/非final方法/abstract方法</strong>中<strong>传入或返回对象</strong>（<strong>局部变量引用了对象，并逃离该栈帧</strong>，即发生<strong>引用泄漏</strong>），则子类可对父类方法进行重写（<strong>外星方法</strong>），以实现对该局部变量的并发增删（方法内部开启线程对变量进行操作），此时局部变量成为共享变量，仍将引发线程安全问题</li> <li>Java Web环境</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
  <span class="token comment">// 无状态，线程安全</span>
  <span class="token keyword">private</span> <span class="token class-name">UserDao</span> userDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 非线程安全</span>
  <span class="token keyword">private</span> <span class="token class-name">Integer</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomAspect</span> <span class="token punctuation">{</span> <span class="token comment">// 单例</span>
  <span class="token comment">// 非线程安全</span>
  <span class="token keyword">private</span> <span class="token class-name">Long</span> start <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
  
  <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">&quot;execution(* *(..))&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">&quot;execution(* *(..))&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>解决方式：采用环绕通知，将计时器用作局部变量</p> <h3 id="synchronized锁的优化"><a href="#synchronized锁的优化" class="header-anchor">#</a> <code>synchronized</code>锁的优化</h3> <h4 id="轻量级锁"><a href="#轻量级锁" class="header-anchor">#</a> 轻量级锁</h4> <p>多线程访问没有竞争现象，优先使用轻量级锁</p> <ol><li><p>创建锁记录（Lock Record）对象</p></li> <li><p>锁记录对象中<strong>Object Reference</strong>指向加锁对象，并尝试通过CAS将锁记录对象中<strong>地址字段</strong>（<code>ptr_to_lock_record:30</code> | <code>00</code>）与加锁对象的Mark Word（非加锁状态下末两位为<code>01</code>）替换</p> <p>（若CAS失败，进行锁的<strong>膨胀</strong>；或进行轻量级锁<strong>重入</strong>，额外维护一个新的锁记录对象信息）</p></li> <li><p>（解锁）通过CAS进行解锁，还原加锁对象的Mark Word（若CAS失败，执行重量级锁的解锁流程）</p></li></ol> <h4 id="偏向锁-轻量级锁的优化"><a href="#偏向锁-轻量级锁的优化" class="header-anchor">#</a> 偏向锁（轻量级锁的优化）</h4> <p>在加锁对象的Mark Word字段中加入当前线程的ID信息，当同一线程再次对该对象进行加锁时避免反复的CAS操作；当其他线程对该对象进行加锁时撤销该对象的偏向状态</p> <ul><li>批量重偏向：当反复出现新线程对该对象进行加锁的情况时，不再直接撤销该对象的偏向状态，而是修改该类所有新实例对象的偏向状态为偏向新线程（偏向撤销阈值：20）</li> <li>批量偏向撤销：当再次反复出现另一新线程对该对象进行加锁的情况时，不再修改该对象的偏向状态，而是直接禁用该类所有新实例对象的偏向资格（偏向撤销阈值：40）</li></ul> <blockquote><p>因对象的Mark Word字段在不可偏向时才包含hashCode信息（在可偏向时替换为偏向线程ID与epoch信息），故显式调用加锁对象的<code>hashCode()</code>方法将撤销该对象的偏向状态（<code>1 | 01</code> -&gt; <code>0 | 01</code>，倒数第三位为偏向状态，1为可偏向，0为不可偏向）</p></blockquote> <h4 id="重量级锁"><a href="#重量级锁" class="header-anchor">#</a> 重量级锁</h4> <ol><li>为加锁对象申请Monitor锁，将加锁对象的轻量级锁记录地址字段再次替换为Monitor锁地址（<code>ptr_to_monitor:30</code> | <code>10</code>）</li> <li>当前线程进入Monitor锁的Entry List，进入**<code>BLOCKED</code>**状态</li> <li>（解锁）通过加锁对象的Monitor锁地址信息定位Monitor锁，设置Monitor锁的Owner对象为空，并唤醒Monitor锁Entry List中阻塞的线程（非公平锁）</li></ol> <blockquote><p>自旋优化</p></blockquote> <h4 id="锁消除"><a href="#锁消除" class="header-anchor">#</a> 锁消除</h4> <p>当加锁对象未逃逸局部代码块的作用范围（不可能成为共享变量）时，JIT将锁消除</p> <h2 id="线程等待与通知"><a href="#线程等待与通知" class="header-anchor">#</a> 线程等待与通知</h2> <h3 id="object-wait-notify"><a href="#object-wait-notify" class="header-anchor">#</a> (<code>Object</code>)<code>wait()</code>/<code>notify()</code></h3> <h4 id="底层原理"><a href="#底层原理" class="header-anchor">#</a> 底层原理</h4> <p>在锁对象上调用<code>wait()</code>前必须确保获取对象的锁（在同步代码块中进行），并发生锁的膨胀（即只使用重量级锁），当前线程进入<code>Monitor</code>锁的Wait Set进行等待（<code>park()</code>）并释放锁；在锁对象上调用<code>notify()</code>前也必须确保获取对象的锁（在同步代码块中进行），<u>在退出同步块时</u>对应线程被真正唤醒（<code>unpark()</code>）后回到Entry List中进行阻塞，直至再次竞争锁成功，继续执行<code>wait()</code>后代码</p> <ul><li><code>notifyAll()</code>按照LIFO顺序唤醒Entry List中阻塞的线程</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 线程A，消费者</span>
<span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 使用while循环而非if，从而在线程被唤醒后保证等待条件不满足时才继续执行，以避免虚假唤醒</span>
  	lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
  <span class="token comment">// 执行正常流程</span>
<span class="token punctuation">}</span>

<span class="token comment">// 线程B，生产者</span>
<span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
  lock.notify()将随机唤醒Entry List中的线程，故可能造成虚假唤醒
  */</span>
  lock<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><h5 id="同步模式之保护性暂停-guarded-suspension-模式"><a href="#同步模式之保护性暂停-guarded-suspension-模式" class="header-anchor">#</a> 同步模式之保护性暂停（Guarded Suspension）模式</h5> <p>当线程t1等待线程t1的执行结果，可分别关联同一个<code>GuardedObject</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Object</span> lock<span class="token punctuation">;</span>
<span class="token class-name">Object</span> response<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 记录初始时间</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>response <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// 判断消耗时间passedTime是否超过timeout，若是则退出循环</span>
			<span class="token comment">/*
			当被虚假唤醒后重新进入循环时，应该继续等待的时间为timeout - passedTime
			*/</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>timeout <span class="token operator">-</span> passedTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> response<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token class-name">Object</span> rawObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		response <span class="token operator">=</span> rawObject<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>一个生产者通过<code>GuardedObject</code>对象严格对应一个消费者</li> <li>相比于<code>join()</code>（原理一致），上述模式中消费者无需等待生产者线程完全结束就能消费资源</li></ul> <h5 id="异步模式之异步队列模式-生产者-消费者"><a href="#异步模式之异步队列模式-生产者-消费者" class="header-anchor">#</a> 异步模式之异步队列模式（生产者/消费者）</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">LinkedList</span> list<span class="token punctuation">;</span>
<span class="token keyword">int</span> capacity<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">synchronized</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 		<span class="token keyword">while</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      list<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 		<span class="token punctuation">}</span>

    <span class="token class-name">Object</span> o <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> o<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Object</span> rawObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">synchronized</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 		<span class="token keyword">while</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      list<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 		<span class="token punctuation">}</span>
    
    list<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote> <h3 id="conditionobject-await-signal"><a href="#conditionobject-await-signal" class="header-anchor">#</a> (<code>ConditionObject</code>)<code>await</code>/<code>signal</code></h3> <p><img src="/assets/img/await_signal.8705164b.png" alt="img"></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 借助await/signal机制实现生产者/消费者模型</span>

<span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Condition</span> condition1 <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 线程A，消费者</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
	lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">{</span>
  	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token comment">/*执行条件A不满足*/</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			condition1<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
  	<span class="token comment">// 执行业务操作</span>
	<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
  	lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 线程B，生产者</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
	lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 更改执行条件A</span>
  	condition1<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
  	lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="底层原理-2"><a href="#底层原理-2" class="header-anchor">#</a> 底层原理</h4> <p>在<code>ConditionObject</code>条件对象上（对当前线程）调用<code>await()</code>，当前线程若竞争lock成功，则尾插入进AQS等待队列中进行等待（<code>park()</code>）并释放lock；在<code>ConditionObject</code>条件对象上调用<code>signal()</code>将该线程转移至AQS阻塞队列中进行阻塞，直至再次竞争lock成功后被唤醒（<code>unpark()</code>），继续执行<code>await()</code>后代码</p> <ul><li><code>signalAll()</code>按照FIFO顺序唤醒AQS阻塞队列中阻塞的线程</li></ul> <h5 id="await"><a href="#await" class="header-anchor">#</a> <code>await()</code></h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 1. 将当前线程包装成Node，尾插入到AQS等待队列中</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2. 释放当前线程所占用的lock，在释放的程中会唤醒AQS阻塞队列中的下一个节点</span>
    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 3. 当前线程进入到等待状态</span>
        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 4. 自旋等待获取同步状态/lock（成功获取lock是退出await()的充要条件）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>
        interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span>
        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 5. 处理中断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="signal"><a href="#signal" class="header-anchor">#</a> <code>signal()</code></h5> <p>将AQS等待队列中等待时间最长的节点移动到AQS阻塞队列中</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//1. 先检测当前线程是否已经获取lock</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//2. 获取AQS等待队列中头节点，将其移动至AQS阻塞队列中等待再次获取lock从而被唤醒</span>
    <span class="token class-name">Node</span> first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token comment">// doSignal(Node)中的transferForSignal(Node)方法实现对头节点的状态检查、队列转移与（后续的）线程unpark</span>
        <span class="token function">doSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><strong><code>Object.wait()</code>/<code>Object.notify()</code>与<code>Condition.await()</code>/<code>Condition.signal()</code>区别</strong></p> <p>前者与<code>Monitor</code>配合完成线程间的等待/通知机制，是java底层级别的；而后者与<code>Lock</code>配合完成等待/通知机制，是语言级别的，具有更高的可控性和扩展性</p> <ul><li><p>后者支持不响应中断，而前者不支持</p></li> <li><p>后者支持多个等待队列（借助多个<code>ConditionObject</code>对象实现），而前者只支持一个</p></li> <li><p>后者支持超时时间的设置，而前者不支持</p></li></ul></blockquote> <h2 id="lock锁-java-util-concurrent-locks"><a href="#lock锁-java-util-concurrent-locks" class="header-anchor">#</a> <code>Lock</code>锁（<code>java.util.concurrent.locks.*</code>）</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>无参构造器默认构造<strong>非公平锁</strong></li> <li>支持在多个条件变量上进行等待，在唤醒时可按照不同的条件变量进行精确唤醒</li></ul> <h3 id="abstractqueuedsynchronizer-aqs"><a href="#abstractqueuedsynchronizer-aqs" class="header-anchor">#</a> <code>AbstractQueuedSynchronizer</code>（AQS）</h3> <p>Lock等同步组件主要专注于实现同步语义，而AQS负责同步状态管理，线程排队、等待与唤醒等底层操作</p> <h4 id="核心组件"><a href="#核心组件" class="header-anchor">#</a> 核心组件</h4> <ul><li><p><code>State</code>同步状态</p> <p>通过<code>State</code>体现加锁状态与重入次数</p> <p>子类通过<code>getState()</code>/<code>setState()</code>/<code>compareAndSetState()</code>重写AQS用来改变同步状态的若干protected方法</p> <p>对同步状态的获取/释放可分为<strong>独占模式</strong>与<strong>共享模式</strong></p></li> <li><h5 id="abstractqueuedsynchronizer-node双向阻塞队列"><a href="#abstractqueuedsynchronizer-node双向阻塞队列" class="header-anchor">#</a> <code>AbstractQueuedSynchronizer$Node</code>双向阻塞队列</h5> <p>阻塞队列/同步队列（双向链表，FIFO队列）</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span> <span class="token comment">// 节点状态</span>
<span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span> <span class="token comment">// 当前节点/线程的前驱节点</span>
<span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span> <span class="token comment">// 当前节点/线程的后继节点</span>
<span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span> <span class="token comment">// 加入同步队列的线程引用</span>

<span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span>
<span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> tail<span class="token punctuation">;</span>
</code></pre></div><ul><li><p>等待队列/条件队列（单向链表）：<code>ConditionObject</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> firstWaiter<span class="token punctuation">;</span> <span class="token comment">// 等待队列中的头节点</span>
<span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> lastWaiter<span class="token punctuation">;</span> <span class="token comment">// 等待队列中的尾节点</span>
<span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span> <span class="token comment">// 等待队列中的下一个节点</span>
</code></pre></div></li></ul></li></ul> <blockquote><p><code>*Lock</code> -&gt; <code>Lock</code> -&gt; <code>AbstractQueuedSynchronizer</code> -&gt; <code>Sync</code></p> <h6 id="模板方法设计模式"><a href="#模板方法设计模式" class="header-anchor">#</a> 模板方法设计模式</h6> <p><code>tryAcquire(int)</code>等方法被<code>*Sync</code>子类重写（其中<code>*Sync</code>子类为<code>*Lock</code>子类的静态内部类），当<code>*Sync</code>子类调用<code>acquire(int)</code>等AQS模板方法时就会调用已被本类重写的方法；同步组件通过AQS提供的模板方法实现同步语义</p> <ul><li><code>tryAcquire(int)</code>：独占式获取与释放同步状态</li> <li><code>tryRelease(int)</code></li> <li><code>tryAcquireShared(int)</code>：共享式获取与释放同步状态</li> <li><code>tryReleaseShared(int)</code></li> <li><code>isHeldExclusively()</code>：查询同步队列中等待线程情况</li></ul> <p>同步器是实现锁的关键：利用同步器可实现锁的语义。锁面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作。锁和同步器针对使用者和实现者实现了关注点分离。</p></blockquote> <h4 id="独占锁-共享锁的获取与释放"><a href="#独占锁-共享锁的获取与释放" class="header-anchor">#</a> 独占锁/共享锁的获取与释放</h4> <h5 id="acquire-int"><a href="#acquire-int" class="header-anchor">#</a> <code>acquire(int)</code></h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 尝试获取State，获取失败时进入阻塞队列</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
      <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// ...</span>

<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 基于当前线程构建Node节点</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2. 查看当前尾节点是否为空</span>
    <span class="token class-name">Node</span> pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将当前节点以“CAS尾插”的方式插入阻塞队列中</span>
        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 当前阻塞队列尾节点为null，说明当前线程是第一个加入阻塞队列进行等待的线程：</span>
    <span class="token comment">// 1. 调用compareAndSetHead(new Node())方法，完成阻塞队列头结点的初始化</span>
		<span class="token comment">// 2. 自旋不断尝试CAS尾插入直至成功为止</span>
    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          	<span class="token comment">// 若前驱节点为头节点，再次尝试获取State</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              	<span class="token comment">// 获取State成功，队列头指针指向当前节点并释放前驱节点</span>
                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          	<span class="token comment">// 获取State失败，线程进入等待状态（通过CAS将节点状态由INITIAL设置成SIGNAL）</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// parkAndCheckInterrupt()借助LockSupport.park()真正实现线程阻塞</span>
                interrupted <span class="token operator">|=</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span>
            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="/assets/img/aqs_acquire.fce76401.png" alt="img"></p> <h5 id="release-int"><a href="#release-int" class="header-anchor">#</a> <code>release(int)</code></h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尝试释放State</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token comment">// 释放State成功，唤醒队列头节点后继节点所引用线程（FIFO队列），其中借助LockSupport.unpark()真正实现线程唤醒</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>acquireInterruptibly(int)</code></p> <p><code>tryAcquireNanos(int)</code></p> <h5 id="acquireshared-int"><a href="#acquireshared-int" class="header-anchor">#</a> <code>acquireShared(int)</code></h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="releaseshared-int"><a href="#releaseshared-int" class="header-anchor">#</a> <code>releaseShared(int)</code></h5> <h3 id="reentrantlock及其实现原理"><a href="#reentrantlock及其实现原理" class="header-anchor">#</a> <code>ReentrantLock</code>及其实现原理</h3> <h4 id="锁的竞争"><a href="#锁的竞争" class="header-anchor">#</a> 锁的竞争</h4> <h5 id="非公平锁-默认"><a href="#非公平锁-默认" class="header-anchor">#</a> 非公平锁（默认）</h5> <p>线程第一次获取锁时不对<code>Node</code>阻塞队列进行检查，直接通过CAS尝试争抢<code>State</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// Class NonFairSync</span>

<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><ol><li><p>若前驱节点为头节点，<code>tryAcquire()</code>再次尝试获取锁</p> <ol><li><p>获取锁成功</p> <ol><li><p>将前驱节点置为空，当前节点置为头节点；</p> <p><code>waitStatus</code>设置为1，Sync对象的<code>exclusiveOwnerThread</code>设置为当前节点所关联线程</p></li></ol></li> <li><p>获取锁失败</p> <ol><li><p>将前驱节点的<code>waitStatus</code>设置为-1（前驱节点有责任对本节点进行唤醒操作）；</p> <p><code>tryAcquire()</code>再次尝试获取锁，随后调用<code>LockSupport.park()</code>进行阻塞</p></li></ol></li></ol></li> <li><p>释放锁：<code>waitStatus</code>设置为0，（若<code>waitStatus</code>为-1）对阻塞队列中下一节点进行唤醒操作</p></li></ol> <h5 id="公平锁"><a href="#公平锁" class="header-anchor">#</a> 公平锁</h5> <p>线程第一次获取锁时检查<code>Node</code>阻塞队列中是否有前驱节点（检查虚拟头节点的next节点所关联线程是否为本线程），若没有则通过CAS尝试争抢<code>State</code></p> <h4 id="线程的打断"><a href="#线程的打断" class="header-anchor">#</a> 线程的打断</h4> <p><code>acquire()</code></p> <p>线程被打断时，仍停留在<code>Node</code>阻塞队列中，获取锁时能主动执行<code>selfInterrupt()</code>自我中断</p> <p><code>acquireInterruptibly()</code></p> <p>线程被打断时，仍停留在<code>Node</code>阻塞队列中，获取锁时将直接抛出<code>InterruptedException</code></p> <h4 id="线程的等待与唤醒"><a href="#线程的等待与唤醒" class="header-anchor">#</a> 线程的等待与唤醒</h4> <p>持锁线程调用<code>await()</code>进行等待时：</p> <ol><li><code>addConditionWaiter</code>进入等待队列尾部，节点<code>waitStatus</code>改为-2，进行park阻塞</li> <li><code>fullyRelease()</code>完全释放AQS上的可重入锁</li> <li>对阻塞队列下一个节点进行unpark</li></ol> <p>持锁线程调用<code>signal()</code>进行唤醒时：</p> <ol><li><p><code>doSignal(first)</code>对等待队列队首线程进行唤醒</p></li> <li><p><code>transferForSignal()</code>将唤醒线程加入阻塞队列尾部，节点<code>waitStatus</code>改为0，而其前驱节点的<code>waitStatus</code>设置为-1</p> <p>若操作失败（如该线程状态已被设置为取消），则尝试唤醒等待队列下一节点所关联线程</p></li> <li><p>对所唤醒线程进行unpark</p></li></ol> <h3 id="reentrantreadwritelock及其实现原理"><a href="#reentrantreadwritelock及其实现原理" class="header-anchor">#</a> <code>ReentrantReadWriteLock</code>及其实现原理</h3> <ul><li><p>写锁支持条件变量，而读锁不支持</p></li> <li><p>升级与降级</p> <ul><li>读锁在重入时不可升级为写锁，此时会发生死锁</li> <li>写锁在重入时可降级为读锁</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">CachedData</span> <span class="token punctuation">{</span>
  <span class="token class-name">Object</span> data<span class="token punctuation">;</span>
  <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> isCacheValid<span class="token punctuation">;</span>
  <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">void</span> <span class="token function">processCachedData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token operator">!</span>isCacheValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 本地缓存失效，改为获取写锁更新缓存</span>
      <span class="token comment">// 获取写锁前需释放读锁</span>
      lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token operator">!</span>isCacheValid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 双重检查</span>
        <span class="token comment">// set data</span>
        isCacheValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      
      <span class="token comment">// 将写锁降级为读锁</span>
      lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
      lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 真正使用数据</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// use data</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
      lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h4 id="实现原理"><a href="#实现原理" class="header-anchor">#</a> 实现原理</h4> <h3 id="locksupport-park-locksupport-unpark"><a href="#locksupport-park-locksupport-unpark" class="header-anchor">#</a> <code>LockSupport.park()</code>/<code>LockSupport.unpark()</code></h3> <blockquote><p>AQS底层通过<code>park()</code>/<code>unpark()</code>实现线程的状态切换</p></blockquote> <h4 id="park"><a href="#park" class="header-anchor">#</a> <code>park()</code></h4> <ol><li>检查<code>Parker</code>对象的<code>_counter</code>字段</li> <li>若<code>_counter</code>字段值为0，获取mutex，线程进入<code>_condition</code>条件变量进行阻塞</li></ol> <h4 id="unpark"><a href="#unpark" class="header-anchor">#</a> <code>unpark()</code></h4> <ol><li>将<code>Parker</code>对象的<code>_counter</code>字段置为1</li> <li>尝试唤醒<code>_condition</code>条件变量中的指定线程</li></ol> <blockquote><p>线程开始运行时，设置<code>_counter</code>字段为0</p></blockquote> <hr> <h1 id="共享内存模型-无锁-乐观锁-非阻塞式"><a href="#共享内存模型-无锁-乐观锁-非阻塞式" class="header-anchor">#</a> 共享内存模型：无锁（乐观锁，非阻塞式）</h1> <h2 id="cas"><a href="#cas" class="header-anchor">#</a> CAS</h2> <p>CAS操作保证原子性，CAS实现类中借助<code>volatile</code>获取最新值进行比较，以实现线程安全</p> <blockquote><p>CAS操作适合短时间内即可获取到锁的场景，若线程需长时间等待锁释放，优先使用悲观锁</p></blockquote> <h3 id="原子变量-java-util-concurrent-atomic"><a href="#原子变量-java-util-concurrent-atomic" class="header-anchor">#</a> 原子变量（<code>java.util.concurrent.atomic.*</code>）</h3> <h5 id="atomicinteger-atomiclong-atomicboolean"><a href="#atomicinteger-atomiclong-atomicboolean" class="header-anchor">#</a> <code>AtomicInteger</code>/<code>AtomicLong</code>/<code>AtomicBoolean</code></h5> <h5 id="atomicreference"><a href="#atomicreference" class="header-anchor">#</a> <code>AtomicReference</code></h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BigDecimal</span><span class="token punctuation">&gt;</span></span> balance<span class="token punctuation">;</span>

<span class="token comment">// constructor</span>

<span class="token class-name">BigDecimal</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> balance<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">withdrawCash</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 使用乐观锁实现多个组合操作的原子性（BigDecimal单个方法为线程安全）</span>
    <span class="token class-name">BigDecimal</span> prev <span class="token operator">=</span> balance<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">BigDecimal</span> next <span class="token operator">=</span> prev<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>balance<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>ABA问题</p> <ul><li><code>AtomicStampedReference</code></li> <li><code>AtomicMarkableReference</code></li></ul></blockquote> <h5 id="atomicintegerarray"><a href="#atomicintegerarray" class="header-anchor">#</a> <code>AtomicIntegerArray</code></h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">AtomicIntegerArray</span> states <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicIntegerArray</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ...</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>states<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>states<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取数组中某元素锁，进行操作（如用于自定义连接池返回可用连接）</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 获取数组中某元素锁，等待，避免循环空转消耗性能（需长时间等待锁释放，使用悲观锁）</span>
  <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="atomicfieldupdator"><a href="#atomicfieldupdator" class="header-anchor">#</a> <code>AtomicFieldUpdator</code></h5> <h5 id="longadder"><a href="#longadder" class="header-anchor">#</a> <code>LongAdder</code></h5> <blockquote><p><code>LongAdder</code>源码分析</p> <ul><li>CAS锁</li></ul></blockquote> <h3 id="unsafe"><a href="#unsafe" class="header-anchor">#</a> <code>Unsafe</code></h3> <h3 id="不可变类"><a href="#不可变类" class="header-anchor">#</a> 不可变类</h3> <ul><li><code>DateTimeFormatter</code></li> <li><code>String</code></li></ul> <h6 id="不可变类对象的设计"><a href="#不可变类对象的设计" class="header-anchor">#</a> 不可变类对象的设计</h6> <blockquote><p><code>String</code>类的保护性（防御性）拷贝：在有可能对本对象发生修改时，创建新对象返回，因此是线程安全的</p> <ul><li><p><code>String#substring()</code></p> <p>未解决对象实例创建过于频繁的问题，引入<strong>享元模式</strong></p> <ul><li><p>基本类型包装类</p> <p>在包装类对象创建之前，内部Cache对象已经将需缓存的对象全部创建完成</p> <div class="language-jav extra-class"><pre class="language-text"><code>// Use the archived cache if it exists and is large enough
if (archivedCache == null || size &gt; archivedCache.length) {
	Integer[] c = new Integer[size];
	int j = low;
	for(int i = 0; i &lt; c.length; i++) {
		c[i] = new Integer(j++);
	}
	archivedCache = c;
}
cache = archivedCache;

// range [-128, 127] must be interned (JLS7 5.1.7)
assert IntegerCache.high &gt;= 127;
</code></pre></div><ul><li><code>Byte</code>、<code>Short</code>、<code>Long</code>：-128～127</li> <li><code>Integer</code>：-128～127（最大值可通过<code>-Djava.lang.Integer.IntegerCache.high</code>调整）</li> <li><code>Character</code>：0～127</li> <li><code>Boolean</code>：true、false</li></ul></li> <li><p>字符串常量池</p></li> <li><p><code>BigDecimal</code>/<code>BigInteger</code></p></li></ul></li></ul></blockquote> <hr> <h1 id="jmm"><a href="#jmm" class="header-anchor">#</a> JMM</h1> <p>Java内存模型（Java Memory Model，JMM）定义在Java虚拟机规范中，用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步访问共享变量。</p> <p>JVM内存分区与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆：线程栈和堆可能都分布于主内存中，部分线程栈和堆还可能出现在CPU寄存器与高速缓存中：</p> <p><img src="/assets/img/jmm.f3220bd8.jpg" alt="img"></p> <p>因此，JMM还定义了JVM内存分区与硬件内存架构之间的抽象关系：</p> <p>线程</p> <p>​     ｜</p> <p>工作内存（对应CPU寄存器与高速缓存）</p> <p>​     ｜</p> <p>主内存（对应主存）</p> <ol><li><p>针对主存、高速缓存及CPU寄存器之间的具体交互细节，常用的缓存一致性协议：MSI、MESI(IllinoisProtocol)、MOSI、Synapse、Firefly及DragonProtocol</p></li> <li><p>针对主内存与工作内存之间的具体交互细节，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存，JMM定义了八种操作：</p> <p>(<code>lock</code>-<code>unlock</code>)-&gt;<code>read</code>-&gt;<code>load</code>-&gt;<code>use</code>-&gt;<code>assign</code>-&gt;<code>store</code>-&gt;<code>write</code></p></li></ol> <h2 id="可见性-读同步问题"><a href="#可见性-读同步问题" class="header-anchor">#</a> 可见性（读同步问题）</h2> <h4 id="volatile"><a href="#volatile" class="header-anchor">#</a> <code>volatile</code></h4> <p>保证代码块内共享变量的可见性（每次只从主存，而非工作内存中读取），但不能保证代码块执行的原子性，故多用于“一写多读”的场景</p> <ul><li><code>LOAD</code>前缀指令实现读写屏障</li> <li>MESI缓存一致性与总线嗅探</li></ul> <blockquote><ul><li><code>synchronized</code>可保证代码块的执行原子性及变量可见性（强制刷新工作内存），但一般为重量级操作，性能较低</li> <li><code>System.out.print()</code>语句内部有加锁操作，在IO操作后强制刷新工作内存，因此若代码块内有输出操作可不将共享变量声明为<code>volatile</code></li></ul></blockquote> <blockquote><p><strong>二阶段终止模式</strong>实现监控流程</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 非监控线程调用stopMonitor()方法，两共享变量必须在线程间保证可见性</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> isStarted<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> isStopped<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">Thread</span> monitor<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isStarted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 只需将读写共享变量部分纳入同步代码块（缩小同步范围，提升并发性能）</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>isStarted<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// balking（犹豫）模式</span>
 		<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		isStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> 
<span class="token punctuation">}</span>

<span class="token comment">/*
以下代码不会被多个线程并发执行，故无需加锁，因此所用到的共享变量需声明为volatile
*/</span>
	monitor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>isStopped<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token keyword">try</span> <span class="token punctuation">{</span>
    	<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token comment">/*
    	执行监控业务
    	*/</span>
  	<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 借助isStopped共享变量实现循环优雅退出，不再依赖打断标记</span>
   <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

 <span class="token comment">/*
 释放资源
 */</span>
 isStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	monitor<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stopMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
isStopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	monitor<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 显式打断，以更快结束可能存在的sleep()</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote> <h4 id="threadlocal"><a href="#threadlocal" class="header-anchor">#</a> <code>ThreadLocal</code></h4> <p>提供线程内部的局部变量，不同的线程间访问自身变量不会互相干扰（“空间（变量副本）换时间（并行执行）”）；作用于线程的整个生命周期，降低同一线程内多方法/组件间公共变量传递的复杂度</p> <ul><li>数据传递：独立保存各个线程绑定的数据，可在同一线程内多方法/组件间安全传递，避免额外传递参数所造成的代码耦合</li> <li>线程隔离：各个线程绑定的数据相互隔离，但又支持并发存取，避免引入同步代码块所造成的性能损失</li></ul> <blockquote><h6 id="threadlocal使用场景"><a href="#threadlocal使用场景" class="header-anchor">#</a> <code>ThreadLocal</code>使用场景</h6> <ul><li><p>多线程场景下，跨service-dao层传递原生<code>JDBC Connection</code>，使用<code>ThreadLocal</code>保证同一线程内两层间传递同一<code>JDBC Connection</code>（<u>数据库连接池实现思路</u>）</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Connection</span><span class="token punctuation">&gt;</span></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">DataSource</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SomeDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Connection</span> <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
  <span class="token class-name">Connection</span> conn <span class="token operator">=</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>conn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    conn <span class="token operator">=</span> ds<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> conn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></blockquote> <h5 id="threadlocalmap"><a href="#threadlocalmap" class="header-anchor">#</a> <code>ThreadLocalMap</code></h5> <p>k:<code>ThreadLocal</code>对象 - v:该对象对应的变量副本</p> <h6 id="以上kv键值对设计的优势"><a href="#以上kv键值对设计的优势" class="header-anchor">#</a> 以上kv键值对设计的优势</h6> <ul><li>以<code>ThreadLocal</code>对象而非<code>Thread</code>对象本身作为key，每个Map存储的Entry数量降低</li> <li><code>ThreadLocalMap</code>对象由<code>Thread</code>对象本身进行维护，当<code>Thread</code>销毁时，<code>ThreadLocalMap</code>对象随之销毁</li></ul> <div class="language-mermaid extra-class"><pre class="language-text"><code>classDiagram
  class ThreadLocalMap
  ThreadLocalMap : +set(ThreadLocal&lt;?&gt; key, T value)
  ThreadLocalMap : +remove(ThreadLocal&lt;?&gt; key)
  ThreadLocalMap : +getEntry(ThreadLocal&lt;?&gt; key)
  ThreadLocalMap : +int INITIAL_CAPACITY
  ThreadLocalMap : +int size
  ThreadLocalMap : +int threshold
  ThreadLocalMap : +Entry[] table
</code></pre></div><h6 id="threadlocal常用方法"><a href="#threadlocal常用方法" class="header-anchor">#</a> <code>ThreadLocal</code>常用方法</h6> <h6 id="threadlocal-set-t-value"><a href="#threadlocal-set-t-value" class="header-anchor">#</a> <code>ThreadLocal.set(T value)</code></h6> <ol><li>获取当前线程对象t与线程对象内Map（t.threadLocals，即<code>ThreadLocalMap</code>对象）</li> <li>若所获取的Map不为空，调用<code>ThreadLocalMap.set(ThreadLocal&lt;?&gt; key, T value)</code>为以当前<code>ThreadLocal</code>对象作为key的<code>ThreadLocalMap.Entry</code>赋值；否则调用<code>createMap(Thread t, T firstValue)</code>创建线程内Map并赋予初始值</li></ol> <h6 id="threadlocal-get"><a href="#threadlocal-get" class="header-anchor">#</a> <code>ThreadLocal.get()</code></h6> <ol><li>获取当前线程对象t与线程对象内Map</li> <li>若所获取的Map不为空，调用<code>ThreadLocalMap.getEntry(ThreadLocal&lt;?&gt; key)</code>获取以当前<code>ThreadLocal</code>对象作为key的<code>ThreadLocalMap.Entry</code>，进而获取<code>ThreadLocalMap.Entry.value</code>返回</li> <li>若获取的Map或Entry为空，调用<code>ThreadLocal.setInitialValue()</code>进行Map赋值或Map初始化（同<code>ThreadLocal.set(T value)</code>流程第二步）后返回</li></ol> <h6 id="threadlocal-remove"><a href="#threadlocal-remove" class="header-anchor">#</a> <code>ThreadLocal.remove()</code></h6> <ol><li>获取当前线程对象t与线程对象内Map</li> <li>若所获取的Map不为空，调用<code>ThreadLocalMap.remove(ThreadLocal&lt;?&gt; key)</code>移除以当前<code>ThreadLocal</code>对象作为key的<code>ThreadLocalMap.Entry</code></li></ol> <blockquote><p>引用链：Thread -&gt; ThreadLocalMap -&gt; ThreadLocalMap.Entry =&gt; ThreadLocal</p> <p><code>ThreadLocalMap.Entry</code>继承<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，以便实现**<code>ThreadLocal</code>生命周期与线程生命周期的解绑**</p> <h4 id="threadlocal可能产生的内存泄漏问题"><a href="#threadlocal可能产生的内存泄漏问题" class="header-anchor">#</a> <code>ThreadLocal</code>可能产生的内存泄漏问题</h4> <p>（某线程运行时）若不及时对该线程中不再使用的<code>ThreadLocal</code>变量<code>threadLocalA</code>进行显式<code>remove()</code>操作，虽然该线程对应<code>ThreadLocalMap</code>的key值（即<code>threadLocalA</code>变量本身）将在本次GC时被置为空（弱引用），但<code>ThreadLocalMap.Entry</code>及<code>ThreadLocalMap.Entry.value</code>均无法<strong>立即</strong>得到释放（强引用），且后者再无主动访问机会（key为空），造成内存泄漏</p> <p>（即使未进行显式<code>remove()</code>操作）下一次执行<code>ThreadLocalMap.getEntry(..)</code>/<code>set(..)</code>方法时将对空key进行检查与清理（<code>expungeStaleEntry(int staleSlot)</code>），故<strong>在一定情况下，所发生的内存泄漏将被自动解决</strong>（<u>弱引用的好处</u>）</p> <p>因此，需在<code>ThreadLocal</code>变量使用结束后显式调用<code>ThreadLocal.remove()</code>对应Entry进行手动删除，以便实现**<code>ThreadLocalMap</code>生命周期与线程生命周期的解绑**，彻底杜绝内存泄漏（<u>显式<code>remove()</code>操作的好处</u>）</p></blockquote> <h5 id="hash冲突"><a href="#hash冲突" class="header-anchor">#</a> Hash冲突</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> firstKey<span class="token punctuation">,</span> <span class="token class-name">Object</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// INITIAL_CAPACITY = 16，可看作环形数组</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> firstKey<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INITIAL_CAPACITY <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hash函数（开放定址法❓）：借助AtomicInteger实现，每次计算hash时自增（getAndAdd）0x61c88647，以维持均匀哈希</span>
    table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">setThreshold</span><span class="token punctuation">(</span>INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 扩容threshold设置为INITIAL_CAPACITY的2/3</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// We don't use a fast path as with get() because it is at</span>
    <span class="token comment">// least as common to use set() to create new entries as</span>
    <span class="token comment">// it is to replace existing ones, in which case, a fast</span>
    <span class="token comment">// path would fail more often than not.</span>
  <span class="token comment">// 相比于getEntry(..)方法直接根据key值定位Entry后采取快速失败策略，set(..)方法采用开放定址·线性探测（环形）法解决hash冲突，直至触发Entry清理与扩容</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="有序性"><a href="#有序性" class="header-anchor">#</a> 有序性</h3> <h5 id="使用volatile修饰单例变量以防止指令重排序"><a href="#使用volatile修饰单例变量以防止指令重排序" class="header-anchor">#</a> 使用<code>volatile</code>修饰单例变量以<strong>防止指令重排序</strong></h5> <ul><li><code>synchronized</code>不能阻止指令重排序，但只要所使用的局部变量不逃离同步代码块的作用范围，则虽有重排序却不会造成有序性问题</li></ul> <h5 id="as-if-serial语义"><a href="#as-if-serial语义" class="header-anchor">#</a> as-if-serial语义</h5> <p>不论如何重排序，程序的执行结果不能与单线程执行结果发生冲突。（编译器、runtime和处理器都必须遵守as-if-serial语义）</p> <h5 id="happens-before规则"><a href="#happens-before规则" class="header-anchor">#</a> happens-before规则</h5> <p>在JMM中，如果一个操作执行的结果需要对另一个操作可见（两个操作既可以是在一个线程之内，也可以是在不同线程之间），那么两操作之间必须满足happens-before规则：</p> <ol><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作</li> <li>监视器锁定规则：对一个锁的解锁操作，happens-before于任意后续对这个锁的加锁操作</li> <li>volatile域规则：对一个volatile域的写操作，happens-before于任意后续对这个volatile域的读操作</li> <li>传递性规则：如果A happens-before B，且B happens-before C，那么A happens-before C</li> <li>线程启动、中断、终结规则</li> <li>对象终结规则</li></ol> <p>以下场景，对共享变量的写操作对其读操作（本线程或其他线程）可见：</p> <ul><li>使用<code>synchronized</code>分别对写操作和读操作加锁</li> <li>对<code>volatile</code>共享变量分别进行写操作和读操作</li> <li>对共享变量的写操作发生在读线程启动之前</li> <li>读操作阻塞直至写操作线程执行结束（<code>Thread.join()</code>）或被打断</li></ul> <blockquote><h4 id="单例模式最佳实践"><a href="#单例模式最佳实践" class="header-anchor">#</a> 单例模式最佳实践</h4> <h5 id="balking-犹豫-模式-配合同步代码块-实现懒汉式单例"><a href="#balking-犹豫-模式-配合同步代码块-实现懒汉式单例" class="header-anchor">#</a> balking（犹豫）模式（配合同步代码块）实现懒汉式单例</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   			<span class="token keyword">return</span> INSTANCE<span class="token operator">:</span>
 		<span class="token punctuation">}</span>
 		INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 		<span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h6 id="锁粒度优化"><a href="#锁粒度优化" class="header-anchor">#</a> 锁粒度优化</h6> <p>缩小同步代码块范围，使用<code>volatile</code>修饰单例对象避免同步代码块重排序，同时使用<strong>double-checked locking</strong>（DCL，双重检查、双检锁）实现懒汉式单例</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 	<span class="token comment">// 同步代码之外的共享变量可能存在有序性问题</span>
 	<span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     		<span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       		INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
     		<span class="token punctuation">}</span>
   		<span class="token punctuation">}</span>
 	<span class="token punctuation">}</span>
 	<span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>其他单例模式</strong></p> <ul><li><h6 id="通过反序列化过程实现的饿汉式单例"><a href="#通过反序列化过程实现的饿汉式单例" class="header-anchor">#</a> 通过反序列化过程实现的饿汉式单例</h6> <ul><li>返回单例使用<code>final</code>防止子类继承破坏单例</li> <li>实现<code>Serializable</code>接口，可重写<code>Object readResolve()</code>方法防止反序列化过程返回多例</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
 	<span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token keyword">return</span> instance<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><h6 id="通过枚举实现的饿汉式单例"><a href="#通过枚举实现的饿汉式单例" class="header-anchor">#</a> 通过枚举实现的饿汉式单例</h6> <p>在类加载阶段保证线程安全，能保证在反序列化仍然返回单例，或在反射过程中因无法获取<code>&lt;init&gt;</code>而无法破坏单例</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
  INSTANCE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><h6 id="借助静态内部类实现的懒汉式单例"><a href="#借助静态内部类实现的懒汉式单例" class="header-anchor">#</a> 借助静态内部类实现的懒汉式单例</h6> <p><strong>静态内部类在使用时才进行类加载</strong>，为懒加载过程</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Class</span> <span class="token class-name">InstanceHolder</span> <span class="token punctuation">{</span>
 		<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 懒汉式，非饿汉式</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 		<span class="token keyword">return</span> <span class="token class-name">InstanceHolder</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span> <span class="token comment">// 调用时执行静态内部类的类加载，类加载阶段JVM保证对&lt;clinit&gt;过程加锁，且将加载的静态成员进行缓存（保证&lt;clinit&gt;方法只执行一次），从而实现线程安全的单例</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></blockquote> <h4 id="内存屏障与final变量"><a href="#内存屏障与final变量" class="header-anchor">#</a> 内存屏障与<code>final</code>变量</h4> <ul><li>LoadLoad</li> <li>StoreStore</li> <li>LoadStore</li> <li><strong>StoreLoad</strong>：在Load2及其后续的读取操作被执行前，保证Store1的写入对所有处理器可见（全能屏障，开销最大）</li></ul> <p>针对<code>final</code>域的重排序规则：</p> <ul><li><p><code>final</code>域构造规则：在构造函数内对一个<code>final</code>域进行构造，随后一个变量对其进行引用，这两个操作之间不能重排序</p> <p>在<code>final</code>域的写操作之后，构造函数返回之前，编译器插入一个storestore屏障，这个屏障禁止处理器把<code>final</code>域的写重排序到构造函数之外</p></li> <li><p>初次读一个包含<code>final</code>域的对象的引用，与随后初次读这个<code>final</code>域，这两个操作之间不能重排序（❓）</p></li></ul> <h2 id="原子性-写同步问题"><a href="#原子性-写同步问题" class="header-anchor">#</a> 原子性（写同步问题）</h2> <ul><li>普通变量：基本数据类型变量、引用类型变量、声明为volatile的任何类型变量的访问读写都具备原子性</li> <li>代码块：使用<code>synchronized</code>关键字实现同步代码块</li></ul> <hr> <h1 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h1> <h3 id="executors"><a href="#executors" class="header-anchor">#</a> <code>Executors</code></h3> <p><strong>实际生产环境中，使用<code>ThreadPoolExecutor(int corePoolSize, // 1 int maximumPoolSize, // 2 long keepAliveTime, // 3 TimeUnit unit, // 4 BlockingQueue&lt;Runnable&gt; workQueue, // 5 ThreadFactory threadFactory, // 6 RejectedExecutionHandler handler // 7)</code>手动创建线程池</strong></p> <blockquote><ul><li>核心线程：开辟新线程执行任务</li> <li>救急线程（非核心线程）：任务数大于<code>corePoolSize</code>时，新任务加入任务队列进行阻塞。若任务队列已满，则临时开辟救急线程执行任务，存活时间为<code>keepAliveTime</code>（<strong>达到存活时间时，被回收的可能是任一线程，不一定是该线程</strong>）；若总线程数超过<code>maximumPoolSize</code>，执行拒绝策略</li></ul></blockquote> <ul><li><p><code>Executors.newFixedThreadPool()</code></p> <p>使用<code>LinkedBlockingQueue</code>（无界），适用于任务数量固定，执行时间较长的场景</p> <p><strong>请求队列的长度为<code>Integer.MAX_VALUE</code>，可能导致大量请求堆积引发OOM</strong></p></li> <li><p><code>Executors.newCachedThreadPool()</code></p> <p>使用<code>SynchronousQueue</code>，适用于任务数量不定，执行时间较短的场景</p> <p><strong>允许创建的线程数量为<code>Integer.MAX_VALUE</code>，可能导致大量线程堆积引发OOM</strong></p></li> <li><p><code>Executors.newSingleThreadExecutor()</code></p> <p>使用<code>FinalizableDelegatedExecutorService</code>对返回的<code>ThreadPoolExecutor</code>对象进行包装，保证外界不能修改<code>ThreadPoolExecutor</code>对象的线程数</p></li> <li><p><code>Executors.newScheduledThreadExecutor()</code></p> <p>原生定时任务</p></li></ul> <h4 id="threadpoolexecutor生命周期方法"><a href="#threadpoolexecutor生命周期方法" class="header-anchor">#</a> <code>ThreadPoolExecutor</code>生命周期方法</h4> <ul><li><p><code>execute()</code>/<code>submit()</code></p> <p>使用<code>submit()</code>方法接收<code>Future</code>对象，可通过返回值（<code>future.get()</code>）对任务中的异常进行捕获</p></li> <li><p><code>invokeAll()</code>/<code>invokeAny()</code></p></li> <li><p><code>shutdown</code>/<code>shutdownNow()</code></p></li> <li><p><code>prestartAllCoreThreads()</code></p> <p>提前创建等于核心线程数的线程数量（线程池预热）</p></li></ul> <blockquote><p>工作线程模式（异步模式、分工模式、享元模式）</p> <p><strong>饥饿现象</strong></p> <p>使用固定大小线程池，当线程数不足时导致的阻塞现象</p> <p>解决方案：不同任务类型交给不同线程池进行处理，避免不同任务对线程的循环依赖</p></blockquote> <h4 id="线程池线程数量选取"><a href="#线程池线程数量选取" class="header-anchor">#</a> 线程池线程数量选取</h4> <blockquote><p>线程数量过多，可能导致系统资源竞争激烈、上下文切换频繁</p> <p>线程数量过少，可能导致系统无法充分利用计算机资源</p></blockquote> <ul><li><p>CPU密集型</p> <p>$\large{CPU核心数+1}$</p></li> <li><p>IO密集型</p> <p>$\Large{\frac{CPU核心数\times{CPU期望利用率}\times{总时间\normalsize{（即CPU耗时+IO耗时）}}}{CPU耗时}}$</p></li></ul> <h4 id="线程池持久化"><a href="#线程池持久化" class="header-anchor">#</a> 线程池持久化</h4> <p>将队列中的任务信息落库，并维护任务状态</p> <h3 id="forkjoinpool"><a href="#forkjoinpool" class="header-anchor">#</a> <code>ForkJoinPool</code></h3> <p>适用于任务可被拆分的场景</p> <hr> <h1 id="并发集合类"><a href="#并发集合类" class="header-anchor">#</a> 并发集合类</h1> <h2 id="hashtable-vector"><a href="#hashtable-vector" class="header-anchor">#</a> <code>HashTable</code>/<code>Vector</code></h2> <p><code>put()</code>/<code>get()</code>方法均为<code>synchronized</code>同步方法，并发度低</p> <h2 id="collections-synchronized"><a href="#collections-synchronized" class="header-anchor">#</a> <code>Collections.Synchronized*</code></h2> <p><code>put()</code>/<code>get()</code>方法内均对同一<code>mutex</code>对象加入<code>synchronized</code>同步锁，并发度低</p> <h2 id="blocking"><a href="#blocking" class="header-anchor">#</a> <code>Blocking*</code></h2> <h3 id="linkedblockingqueue"><a href="#linkedblockingqueue" class="header-anchor">#</a> <code>LinkedBlockingQueue</code></h3> <h3 id="arrayblockingqueue"><a href="#arrayblockingqueue" class="header-anchor">#</a> <code>ArrayBlockingQueue</code></h3> <p>定长环形数组</p> <h2 id="copyonwrite"><a href="#copyonwrite" class="header-anchor">#</a> <code>CopyOnWrite*</code></h2> <h3 id="copyonwritearraylist"><a href="#copyonwritearraylist" class="header-anchor">#</a> <code>CopyOnWriteArrayList</code></h3> <p>无锁读，有锁写</p> <h2 id="concurrent"><a href="#concurrent" class="header-anchor">#</a> <code>Concurrent*</code></h2> <h3 id="concurrenthashmap"><a href="#concurrenthashmap" class="header-anchor">#</a> <code>ConcurrentHashMap</code></h3> <h4 id="_7︎⃣-分段锁"><a href="#_7︎⃣-分段锁" class="header-anchor">#</a> 7︎⃣ “分段锁”</h4> <p><strong><code>Segment</code>数组每一元素（<code>Segment</code>分段，继承自<code>ReentrantLock</code>）对应一把锁，每一分段可视作小型<code>HashMap</code>，内部维护多个<code>HashEntry</code>数组</strong></p> <h5 id="put"><a href="#put" class="header-anchor">#</a> <code>put()</code></h5> <ol><li><p>通过哈希函数计算出当前key的hash值</p></li> <li><p>通过hash值计算出所对应的<code>Segment</code>数组下标</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//计算 Segment 下标</span>
<span class="token punctuation">(</span>hash <span class="token operator">&gt;&gt;&gt;</span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask
</code></pre></div></li> <li><p>再通过hash值计算出所对应的<code>Segment</code>中<code>HashEntry</code>数组下标</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//计算 HashEntry 数组下标</span>
<span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash
</code></pre></div><blockquote><p>尽量避免当前hash值所计算出来的<code>Segment</code>数组下标与<code>HashEntry</code>数组下标趋于相同，导致分配到同一个<code>Segment</code>中的元素都被分配到同一条链表上，导致链表过长，并降低并发度</p></blockquote></li> <li><p>插入元素</p></li></ol> <p><code>ensureSegment()</code></p> <p><code>scanAndLockForPut()</code></p> <p><code>rehash()</code></p> <h5 id="get"><a href="#get" class="header-anchor">#</a> <code>get()</code></h5> <h5 id="size"><a href="#size" class="header-anchor">#</a> <code>size()</code></h5> <p>基于“统计元素个数时<code>Segment</code>结构未发生变化”的假设进行三次尝试，若统计失败，对所有<code>Segment</code>进行强制加锁</p> <h4 id="_8︎⃣-synchronized-cas"><a href="#_8︎⃣-synchronized-cas" class="header-anchor">#</a> 8︎⃣ <code>synchronized</code>+CAS</h4> <p><strong>弃用<code>Segment</code>分段锁，每个链表头节点（Bucket）对应一把（可优化的）同步锁，进一步提高并发度</strong></p> <ul><li>使用CAS优化加锁操作，提高吞吐量</li> <li>弱一致性（fail-safe）</li></ul> <h5 id="构造方法"><a href="#构造方法" class="header-anchor">#</a> 构造方法</h5> <p>在构造器中进行懒惰初始化，只计算数组容量，在第一次使用时才真正创建table数组</p> <ul><li><code>initialCapacity</code></li> <li><code>concurrencyLevel</code>：initialCapacity应至少与concurrencyLevel相等</li> <li><code>loadFactor</code>：取第一个大于initialCapacity/loadFactor值的2幂值作为数组的初始容量，最终存入<code>SIZECTL</code>（默认值为16）</li></ul> <h5 id="put-2"><a href="#put-2" class="header-anchor">#</a> <code>put()</code></h5> <p><code>put(K key, V value)</code>内部调用<code>putVal(key, value, false)</code>，每次设置值时用新值替换旧值</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 若目标键值为空抛出NPE</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// hash函数：(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;  HASH_BITS = 0x7fffffff;</span>
  <span class="token comment">// 与1.8HashMap中hash函数基本一致</span>
  <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Table数组为空，进行初始化</span>
   	<span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 使用CAS（尝试将SIZECTL设置为-1）创建Table数组，并将SIZECTL设置为下一次扩容的阈值大小</span>
      <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Table数组不为空，但key所在位置链表头节点（桶）为空</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token comment">/*key位置无头节点*/</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 使用CAS创建链表头节点（no lock when adding to empty bin）</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Table数组及key所在位置链表头节点（桶）均不为空</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token comment">/*key位置有头节点，但hash值为-1（正在扩容）*/</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用多个工作线程协同进行元素迁移</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     		<span class="token comment">// 如果hash值大于等于0，说明是正常的链表结构</span>
     		<span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      		binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      		<span class="token comment">// 从头结点开始遍历，每遍历一次，binCount计数加1</span>
      		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       			<span class="token class-name">K</span> ek<span class="token punctuation">;</span>
       			<span class="token comment">// 成功根据hash/key/value值找到key，进行值（新值替换旧值）</span>
       			<span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
        			<span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
         			<span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        				oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
         					e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
        					<span class="token keyword">break</span><span class="token punctuation">;</span>
       				<span class="token punctuation">}</span>
       				<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>
       				<span class="token comment">// 若遍历到了尾结点（未找到key），则把新节点尾插进去</span>
       				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        				pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        				<span class="token keyword">break</span><span class="token punctuation">;</span>
       				<span class="token punctuation">}</span>
      			<span class="token punctuation">}</span>
     			<span class="token punctuation">}</span>
     			<span class="token comment">// 判断是否为树节点</span>
     			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      			<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span>
      			binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token comment">// 操作红黑树</span>
      			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       				oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
       				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
        				p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
      			<span class="token punctuation">}</span>
     			<span class="token punctuation">}</span>
    		<span class="token punctuation">}</span>
   		<span class="token punctuation">}</span>
      
      <span class="token comment">// 若binCount达到treeify阈值（8），尝试将链表转为红黑树（检查table容量是否超过64）</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		<span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD<span class="token comment">/*8*/</span><span class="token punctuation">)</span>
     			<span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    		<span class="token comment">//把旧节点值返回</span>
    		<span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
     			<span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
    		<span class="token keyword">break</span><span class="token punctuation">;</span>
   		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 通过CAS进行哈希表元素个数计数，当binCount超过SIZECTL时进行扩容，在真正进行节点迁移时加同步锁</span>
  <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在<strong>链表/红黑树更新/插入值</strong>、<strong>链表转化为红黑树</strong>、及<strong>扩容迁移节点</strong>时加同步锁，减小锁粒度</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 待补充</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * Helps transfer if a resize is in progress.
 */</span>
<span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">ForwardingNode</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>nextTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span>nextTable<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 根据 length 得到一个标识符号</span>
        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果 tab 与 nextTab 都没有被并发修改</span>
        <span class="token comment">// 且 sizeCtl  &lt; 0 （扩容中）</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> nextTable <span class="token operator">&amp;&amp;</span> table <span class="token operator">==</span> tab <span class="token operator">&amp;&amp;</span>
               <span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果 sizeCtl &gt;&gt;&gt; 16 不等于 rs （ sc 前 16 位如果不等于标识符，说明标识符变化了）</span>
            <span class="token comment">// 或者 sizeCtl == rs + 1 （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc == rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。此时 sc == rs + 1）</span>
            <span class="token comment">// 或者 sizeCtl == rs + 65535 （如果达到最大帮助线程的数量，即 65535）</span>
            <span class="token comment">// 或者转移下标正在调整 （扩容结束）</span>
            <span class="token comment">// 结束循环，返回 table</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">&gt;&gt;&gt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span>
                sc <span class="token operator">==</span> rs <span class="token operator">+</span> MAX_RESIZERS <span class="token operator">||</span> transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果以上都不是, 将 sizeCtl 加一 （表示增加了一个线程帮助其扩容）</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 进行转移</span>
                <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> nextTab<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> table<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="get-2"><a href="#get-2" class="header-anchor">#</a> <code>get()</code></h5> <p>无加锁操作，性能较高，但不能保证读取到的是最新数据（<strong>弱一致性</strong>）</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 1. h确保为正整数</span>
  <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// e = tabAt(tab, (n - 1) &amp; h)寻址</span>
  <span class="token comment">// 若hash为负值表明数组正在扩容（-1，forwardingNode）或节点为红黑树（-2，Treebin），调用e.find(h, key)方法在newTable或红黑树中继续寻找</span>
  <span class="token comment">// 若hash为正值，根据hash/key/value值遍历链表节点寻找目标数据</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="concurrentlinkedqueue"><a href="#concurrentlinkedqueue" class="header-anchor">#</a> <code>ConcurrentLinkedQueue</code></h3> <blockquote><h6 id="不同场景下的最优并发集合"><a href="#不同场景下的最优并发集合" class="header-anchor">#</a> 不同场景下的最优并发集合</h6></blockquote> <hr> <h1 id="juc并发工具"><a href="#juc并发工具" class="header-anchor">#</a> JUC并发工具</h1> <blockquote><p>底层基于AQS实现</p></blockquote> <h3 id="stampedlock"><a href="#stampedlock" class="header-anchor">#</a> <code>StampedLock</code></h3> <h3 id="semaphore"><a href="#semaphore" class="header-anchor">#</a> <code>Semaphore</code></h3> <h3 id="countdownlatch"><a href="#countdownlatch" class="header-anchor">#</a> <code>CountdownLatch</code></h3> <h3 id="cyclicbarrier"><a href="#cyclicbarrier" class="header-anchor">#</a> <code>CyclicBarrier</code></h3> <h3 id="completablefuture"><a href="#completablefuture" class="header-anchor">#</a> <code>CompletableFuture</code></h3> <hr> <h1 id="非共享模型"><a href="#非共享模型" class="header-anchor">#</a> 非共享模型</h1></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/posts/java/jvm.html">
					JVM
				</a>
				→
			</span></p></div> <div class="vcomment-container" data-v-07c8026b><div id="vcomments" data-v-07c8026b></div></div> </main> <!----></div><div class="global-ui"><!----><div></div></div></div>
    <script src="/assets/js/app.9bbd0500.js" defer></script><script src="/assets/js/1.7e1accfd.js" defer></script><script src="/assets/js/13.b5619b2f.js" defer></script><script src="/assets/js/7.b57f400b.js" defer></script>
  </body>
</html>
