<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Spring基础 | Felix Mundial的杂烩图书馆</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/icons/favicon.png">
    <meta name="description" content="github page powered by Vuepress">
    
    <link rel="preload" href="/assets/css/0.styles.0e3647e7.css" as="style"><link rel="preload" href="/assets/js/app.9bbd0500.js" as="script"><link rel="preload" href="/assets/js/1.7e1accfd.js" as="script"><link rel="preload" href="/assets/js/13.b5619b2f.js" as="script"><link rel="preload" href="/assets/js/22.d26d3f4d.js" as="script"><link rel="prefetch" href="/assets/js/10.535b18bf.js"><link rel="prefetch" href="/assets/js/11.9f4c7505.js"><link rel="prefetch" href="/assets/js/12.1040a13c.js"><link rel="prefetch" href="/assets/js/14.9065f59b.js"><link rel="prefetch" href="/assets/js/15.1af3a730.js"><link rel="prefetch" href="/assets/js/16.145ee41f.js"><link rel="prefetch" href="/assets/js/17.daef2d0a.js"><link rel="prefetch" href="/assets/js/18.ccf124a3.js"><link rel="prefetch" href="/assets/js/19.3c9e19e5.js"><link rel="prefetch" href="/assets/js/20.cbce51c7.js"><link rel="prefetch" href="/assets/js/21.aad032a5.js"><link rel="prefetch" href="/assets/js/23.36d5eb9b.js"><link rel="prefetch" href="/assets/js/24.3d224717.js"><link rel="prefetch" href="/assets/js/25.e67e5f2e.js"><link rel="prefetch" href="/assets/js/26.26226ddd.js"><link rel="prefetch" href="/assets/js/27.ef309e27.js"><link rel="prefetch" href="/assets/js/28.275159e4.js"><link rel="prefetch" href="/assets/js/29.f7f84fc3.js"><link rel="prefetch" href="/assets/js/3.92bf9476.js"><link rel="prefetch" href="/assets/js/4.7de240dc.js"><link rel="prefetch" href="/assets/js/5.422f2530.js"><link rel="prefetch" href="/assets/js/6.9952df18.js"><link rel="prefetch" href="/assets/js/7.b57f400b.js"><link rel="prefetch" href="/assets/js/8.a18e3f05.js"><link rel="prefetch" href="/assets/js/9.c6f1e43f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0e3647e7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="azure" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name"><i class="el-icon-bicycle"></i> Felix Mundial的杂烩图书馆</span></a> <div class="links"><nav class="nav-links can-hide"><div class="nav-item"><a href="/guide/toc.html" class="nav-link" data-v-c7dec8ac><i class="el-icon-discount"></i> Archives</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/leetcode/leetcode101.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-leetcode"></i> Leetcode</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-java"></i> Java</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/java/concurrency.html" class="nav-link" data-v-c7dec8ac>并发</a></li><li class="dropdown-item"><!----> <a href="/posts/java/jvm.html" class="nav-link" data-v-c7dec8ac>JVM</a></li><li class="dropdown-item"><!----> <a href="/posts/java/spring.html" aria-current="page" class="nav-link router-link-exact-active router-link-active" data-v-c7dec8ac>Spring</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springmvc.html" class="nav-link" data-v-c7dec8ac>Spring MVC</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springboot.html" class="nav-link" data-v-c7dec8ac>Spring Boot</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-database"></i> 数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/database/mysql.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-mysql"></i> MySQL</a></li><li class="dropdown-item"><!----> <a href="/posts/database/redis.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-redis"></i> Redis</a></li></ul></div></div> <!----></nav> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/guide/toc.html" class="nav-link" data-v-c7dec8ac><i class="el-icon-discount"></i> Archives</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/leetcode/leetcode101.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-leetcode"></i> Leetcode</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-java"></i> Java</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/java/concurrency.html" class="nav-link" data-v-c7dec8ac>并发</a></li><li class="dropdown-item"><!----> <a href="/posts/java/jvm.html" class="nav-link" data-v-c7dec8ac>JVM</a></li><li class="dropdown-item"><!----> <a href="/posts/java/spring.html" aria-current="page" class="nav-link router-link-exact-active router-link-active" data-v-c7dec8ac>Spring</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springmvc.html" class="nav-link" data-v-c7dec8ac>Spring MVC</a></li><li class="dropdown-item"><!----> <a href="/posts/java/springboot.html" class="nav-link" data-v-c7dec8ac>Spring Boot</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-database"></i> 数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/database/mysql.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-mysql"></i> MySQL</a></li><li class="dropdown-item"><!----> <a href="/posts/database/redis.html" class="nav-link" data-v-c7dec8ac><i class="iconfont icon-redis"></i> Redis</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/java/concurrency.html" class="sidebar-link">Java并发</a></li><li><a href="/posts/java/jvm.html" class="sidebar-link">JVM</a></li><li><a href="/posts/java/spring.html" aria-current="page" class="active sidebar-link">Spring基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/java/spring.html#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/posts/java/spring.html#事务" class="sidebar-link">事务</a></li></ul></li><li><a href="/posts/java/springboot.html" class="sidebar-link">Spring Boot基础</a></li><li><a href="/posts/java/springmvc.html" class="sidebar-link">Spring MVC基础</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="post-header" data-v-528c0c8a><h2 class="post-title" data-v-528c0c8a><a href="/posts/java/spring.html" data-v-528c0c8a><!---->
			Spring基础
		</a></h2> <div class="post-meta" data-v-528c0c8a><div class="author post-meta-item" data-v-528c0c8a><i class="el-icon-bicycle" data-v-528c0c8a></i> <span data-v-528c0c8a>FelixMundial</span></div> <div class="time post-meta-item" data-v-528c0c8a><i class="el-icon-time" data-v-528c0c8a></i> <time data-v-528c0c8a>2020-11-11</time></div> <div class="category post-meta-item" data-v-528c0c8a><i class="el-icon-collection" data-v-528c0c8a></i> <a href="/category/Spring" class="category-item" data-v-528c0c8a>
				Spring
			</a></div> <div class="tags post-meta-item" data-v-528c0c8a><i class="el-icon-price-tag" data-v-528c0c8a></i> <span class="tag-item el-tag el-tag--light" data-v-528c0c8a>
				JavaWeb
			</span><span class="tag-item el-tag el-tag--light" data-v-528c0c8a>
				Spring
			</span></div> <div id="/posts/java/spring.html" data-flag-title="Spring基础" class="leancloud-visitors post-meta-item" data-v-528c0c8a><i class="el-icon-reading" data-v-528c0c8a></i> <span class="leancloud-visitors-count" data-v-528c0c8a>0</span></div></div></div> <div class="theme-default-content content__default"><h1 id="ioc"><a href="#ioc" class="header-anchor">#</a> IoC</h1> <h3 id="xml配置"><a href="#xml配置" class="header-anchor">#</a> XML配置</h3> <ul><li><p>同一id的Bean对象在容器中的实例，默认作用域为<code>singleton</code><strong>饿汉式</strong>单例（容器创建时就完成单例对象的创建），<code>prototype</code>为<strong>懒汉式</strong>多例（容器创建时不对对象进行创建），每次获取都会创建新的对象实例。单例模式下对象创建后调用<code>init-method</code>，容器销毁后调用<code>destroy-method</code>；原型模式下容器销毁后不会调用<code>destroy-method</code></p></li> <li><p>（使用<code>&lt;property&gt;</code>标签）对象初始化将调用无参构造器，并借助对象的setter方法为对象属性赋值；（使用<code>&lt;constructor-arg&gt;</code>标签）可改为使用含参构造器对对象进行直接初始化和赋值，若存在重载的构造器，则使用标签中的<code>type</code>属性指定装填参数的类型</p></li> <li><p>若不同Bean对象的类型相同，则不能通过<code>getBean(类型)</code>方法获取特定Bean</p></li> <li><p>通过静态工厂创建Bean对象；通过实例工厂创建Bean对象（通过工厂方法）；通过<code>FactoryBean&lt;T&gt;</code>实现类创建Bean对象（<strong>懒汉式</strong>）</p></li> <li><p><code>&lt;context:property-placeholder location=&quot;&quot;&gt;</code>标签为Bean加载外部配置文件</p></li> <li><p>泛型依赖注入</p></li></ul> <h3 id="注解配置"><a href="#注解配置" class="header-anchor">#</a> 注解配置</h3> <ul><li><p>向容器注入Bean</p> <ul><li><code>@Bean</code></li> <li><code>@Import</code>（通过<code>ImportSelector</code>或<code>BeanDefinitionRegistrar</code>手动导入特定bean）</li> <li>实现<code>FactoryBean</code>手动注册</li></ul></li> <li><p>Bean生命周期方法</p> <ul><li><code>@Bean</code>注解中手动指定<code>initMethod</code>与<code>destroyMethod</code>属性</li> <li>实现<code>InitializingBean</code>/<code>DisposableBean</code>指定初始化与销毁方法</li> <li><code>@PostConstruct</code>/<code>@PreDestroy</code></li> <li>实现<code>BeanPostProcessor</code>拦截容器所有对象的生命周期行为</li></ul> <blockquote><ul><li><code>ApplicationContextAwareProcessor</code></li> <li><code>InitDestroyAnnotationBeanPostProcessor</code></li> <li><code>BeanValidationBeanPostProcessor</code></li> <li><code>AsyncAnnotationBeanPostProcessor</code></li></ul></blockquote></li> <li><p>容器组件装配</p></li></ul> <blockquote><ul><li><p><code>@Autowired</code>优先通过Bean类型在容器中搜索组件，若找到多个则通过Bean名称（或通过<code>@Qualifier</code>显式指定的Bean名称）进行进一步装配；若最终未找到相应组件，默认抛出异常（<code>@Autowired(required=true)</code>）</p> <p>可标注在属性、Setter方法、构造器方法（或方法参数）上</p> <blockquote><ul><li>若组件只有一个有参构造器，则参数默认从容器中获取，无需标注<code>@Autowired</code></li> <li>通过<code>@Bean</code>手动注入组件时，方法参数（如果存在）默认从容器中获取，无需标注<code>@Autowired</code></li></ul></blockquote></li> <li><p><code>@Resource</code>只能按照Bean名称进行组件装配</p></li></ul></blockquote> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <h3 id="applicationcontext生命周期"><a href="#applicationcontext生命周期" class="header-anchor">#</a> ApplicationContext生命周期</h3> <div class="language-java extra-class"><pre class="language-java"><code>	<span class="token comment">// AbstractApplicationContext.java</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalStateException</span> <span class="token punctuation">{</span>
		<span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// Prepare this context for refreshing.</span>
			<span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Tell the subclass to refresh the internal bean factory.</span>
			<span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Prepare the bean factory for use in this context.</span>
			<span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token keyword">try</span> <span class="token punctuation">{</span>
				<span class="token comment">// Allows post-processing of the bean factory in context subclasses.</span>
				<span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// Invoke factory processors registered as beans in the context.</span>
				<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
				<span class="token comment">// Register bean processors that intercept bean creation.</span>
				<span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
				<span class="token comment">// Initialize message source for this context.</span>
				<span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// Initialize event multicaster for this context.</span>
				<span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// Initialize other special beans in specific context subclasses.</span>
				<span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// Check for listener beans and register them.</span>
				<span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// Instantiate all remaining (non-lazy-init) singletons.</span>
				<span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
				<span class="token comment">// Last step: publish corresponding event.</span>
				<span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;Exception encountered during context initialization - &quot;</span> <span class="token operator">+</span>
							<span class="token string">&quot;cancelling refresh attempt: &quot;</span> <span class="token operator">+</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>

				<span class="token comment">// Destroy already created singletons to avoid dangling resources.</span>
				<span class="token function">destroyBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// Reset 'active' flag.</span>
				<span class="token function">cancelRefresh</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// Propagate exception to caller.</span>
				<span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">finally</span> <span class="token punctuation">{</span>
				<span class="token comment">// Reset common introspection caches in Spring's core, since we</span>
				<span class="token comment">// might not ever need metadata for singleton beans anymore...</span>
				<span class="token function">resetCommonCaches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><ol><li><h6 id="preparerefresh"><a href="#preparerefresh" class="header-anchor">#</a> <code>prepareRefresh();</code></h6> <ol><li><code>initPropertySource();</code>供子类重写以构造个性化属性（如用于自定义配置中心）</li> <li><code>getEnvironment().validateRequiredProperties();</code>检验个性化属性的合法性</li> <li><code>earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();</code>保存容器中的部分早期事件</li></ol></li> <li><p><code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code></p> <ol><li><code>refreshBeanFactory();</code>刷新（或创建❓）<code>BeanFactory</code></li> <li><code>getBeanFactory();</code>返回刚初始化的<code>DefaultListableBeanFactory</code></li></ol></li> <li><h6 id="preparebeanfactory-beanfactory"><a href="#preparebeanfactory-beanfactory" class="header-anchor">#</a> <code>prepareBeanFactory(beanFactory);</code></h6> <ol><li>配置<code>BeanFactory</code>类加载器、表达式解析器、环境变量信息Map等组件</li> <li>配置<code>ApplicationContextAwareProcessor</code></li> <li>忽略对<code>EnvironmentAware</code>、<code>EmbeddedValueResolveAware</code>实现类的自动配置；设置对<code>BeanFactory</code>、<code>ResourceLoader</code>、<code>ApplicationEventPublisher</code>、<code>ApplicationContext</code>组件的自动配置</li> <li>配置<code>ApplicationListenerDetector</code></li></ol></li> <li><h6 id="postprocessbeanfactory-beanfactory"><a href="#postprocessbeanfactory-beanfactory" class="header-anchor">#</a> <code>postProcessBeanFactory(beanFactory);</code></h6> <ol><li><code>postProcessBeanFactory();</code>供子类重写以在容器预初始化完成时进行进一步的设置</li></ol></li> <li><h6 id="invokebeanfactorypostprocessors-beanfactory"><a href="#invokebeanfactorypostprocessors-beanfactory" class="header-anchor">#</a> <code>invokeBeanFactoryPostProcessors(beanFactory);</code></h6> <p>在<code>BeanFactory</code>标准初始化之后执行：</p> <ol><li><strong>根据是否实现了<code>PriorityOrdered</code>、<code>Order</code>接口分批获取</strong>容器中所有的<code>BeanDefinitionRegistryPostProcessor</code>，<strong>分批排序后分批执行</strong>：
<ol><li><code>invokeBeanDefinitionRegistryPostProcessors(Collection, BeanFactory);</code>执行<code>BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry()</code></li> <li><code>invokeBeanFactoryPostProcessors(Collection, BeanFactory);</code>执行<code>BeanDefinitionRegistryPostProcessor.postProcessBeanFactory()</code></li></ol></li> <li><strong>分批获取</strong>容器中所有的<code>BeanFactoryPostProcessor</code>，<strong>分批排序后分批执行</strong>：
<ol><li><code>invokeBeanFactoryPostProcessors(Collection, BeanFactory);</code>执行<code>BeanFactoryPostProcessor.postProcessBeanFactory()</code></li></ol></li></ol></li> <li><h6 id="registerbeanpostprocessors-beanfactory"><a href="#registerbeanpostprocessors-beanfactory" class="header-anchor">#</a> <code>registerBeanPostProcessors(beanFactory);</code></h6> <p>调用<code>PostProcessorRegistrationDelegate</code>的同名方法完成Bean后置处理器的注册</p> <ol><li>通过类型获取容器中所有已定义但未被创建的<code>BeanPostProcessor</code>，并进行统计与检查（<code>BeanPostPrcessorChecker</code>）</li> <li><strong>分批获取</strong>容器中所有的<code>BeanPostProcessor</code>，<strong>分批排序后分批注册</strong>进<code>BeanFactory</code></li> <li>最后注册<code>MergedBeanDefinitionPostProcessor</code>与<code>ApplicationListenerDetector</code>（在Bean初始化结束后将<code>ApplicationListener</code>的实现类作为应用监听器组件加入容器）</li></ol></li> <li><p><code>initMessageSource();</code>初始化用于消息绑定与消息解析的<code>MessageSource</code>组件</p></li> <li><p><code>initApplicationEventMulticaster();</code>初始化事件派发器</p></li> <li><h6 id="onrefresh"><a href="#onrefresh" class="header-anchor">#</a> <code>onRefresh();</code></h6> <ol><li><code>onRefresh();</code>供子类重写以向容器中注册其他组件❓</li></ol></li> <li><p><code>registerListeners();</code>将容器中的所有应用监听器注册在事件派发器上，并调用<code>multicastEvent(ApplicationEvent)</code>派发可能存在的早期事件</p></li> <li><h4 id="finishbeanfactoryinitialization-beanfactory"><a href="#finishbeanfactoryinitialization-beanfactory" class="header-anchor">#</a> <code>finishBeanFactoryInitialization(beanFactory);</code></h4> <ol><li>...</li> <li><code>preInstantiateSingletons();</code>完成自定义非懒加载单例Bean的初始化</li></ol></li> <li><h6 id="finishrefresh"><a href="#finishrefresh" class="header-anchor">#</a> <code>finishRefresh();</code></h6> <ol><li><code>initLifecycleProcessor();</code>获取容器生命周期处理器和以对容器<code>onRefresh()</code>及<code>onClose()</code>等生命周期方法进行拦截</li> <li><code>getLifecycleProcessor.onRefresh();</code></li> <li><code>publishEvent(new ContextRefreshedEvent(this));</code>发布容器刷新完成事件</li> <li>...</li></ol></li></ol> <h3 id="bean生命周期"><a href="#bean生命周期" class="header-anchor">#</a> Bean生命周期</h3> <h5 id="容器的创建与bean的获取-spring-4-x"><a href="#容器的创建与bean的获取-spring-4-x" class="header-anchor">#</a> 容器的创建与Bean的获取（Spring 4.x）</h5> <ol><li><p>执行<code>ClassPathXmlApplicationContext(String[] configurations, boolean refresh, ApplicationContext parent)</code>或<code>AnnotationConfigApplicationContext(String[] configurations, boolean refresh, ApplicationContext parent)</code>构造器</p></li> <li><p>执行<code>AbstractApplicationContext.refresh()</code>方法：解析配置文件，读取Bean的配置信息并保存在<code>ConfigurableListableBeanFactory</code>对象中：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在<code>AbstractApplicationContext.finishBeanFactoryInitialization(BeanFactory beanFactory)</code>内的最后一步：<code>DefaultListableBeanFactory.preInstantiateSingletons()</code>中完成用户<strong>自定义非懒加载的单实例Bean</strong>的初始化：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// DefaultListableBeanFactory.preInstantiateSingletons()</span>

<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> beanNames<span class="token punctuation">;</span>
<span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取所有将要创建的Bean实例名称</span>
  beanNames <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> beanName <span class="token operator">:</span> beanNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">RootBeanDefinition</span> bd <span class="token operator">=</span> <span class="token function">getMergedLocalBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 依次创建（非抽象、单实例、非懒加载的）Bean实例</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bd<span class="token punctuation">.</span><span class="token function">isAbstract</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> bd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>bd<span class="token punctuation">.</span><span class="token function">isLazyInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFactoryBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 利用重写的BeanFactory.getBean(String beanName)创建Bean</span>
      	<span class="token comment">//final BeanFactory&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(...)</span>
        <span class="token comment">// boolean isEagerInit;</span>
      	<span class="token comment">// ...</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// 调用父类doGetBean()方法创建Bean</span>
          <span class="token function">getBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    	<span class="token punctuation">}</span> 
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// SmartInitializingSingleton子类事件的监听处理器</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> beanName <span class="token operator">:</span> beanNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> singletonInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonInstance <span class="token keyword">instanceof</span> <span class="token class-name">SmartInitializingSingleton</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      smartSingleton<span class="token punctuation">.</span><span class="token function">afterSingletonInstantiated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>DefaultListableBeanFactory.getBean(String beanName)</code>中调用父类<code>doGetBean(..)</code>：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// AbstractBeanFactory.doGetBean(String name, Class&lt;T&gt; requiredType, Object[] args, boolean typeCheckOnly)</span>
<span class="token comment">// ...</span>

<span class="token class-name">Object</span> sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 尝试从单实例Bean缓存（ConcurrentHashMap&lt;String, Object&gt; singletonObjects，单例池）中尝试获取已经创建完成的Bean实例</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>sharedInstance <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> args <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 已找到先前创建的Bean实例</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 未找到先前创建的Bean实例</span>
  <span class="token comment">// ...</span>
  <span class="token function">markBeanAsCreated</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">RootBeanDefinition</span> mbd <span class="token operator">=</span> <span class="token function">getMergedLocalBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// 获取依赖Bean</span>
  	<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dependsOn <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getDependsOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dependsOn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token comment">// 存在依赖Bean，则递归调用getBean(String beanName)对其进行创建</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
      sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ObjectFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 真正实现Bean实例的初始化</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><h6 id="spring如何解决循环依赖"><a href="#spring如何解决循环依赖" class="header-anchor">#</a> Spring如何解决循环依赖？</h6> <p>答：Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池<code>singletonObjects</code>，二级缓存为早期曝光对象<code>earlySingletonObjects</code>，三级缓存为单例对象工厂<code>singletonFactories</code>。</p> <p>当A、B两个类发生循环引用时，在A完成<strong>实例化</strong>后，使用实例化后的对象创建对象工厂，并添加到三级缓存中：如果A被AOP代理，那么工厂中的是A代理后的对象，如果A没有被AOP代理，那么工厂中的是A原本实例化的对象。</p> <p>当A在初始化过程中进行属性注入时，会进行B的创建，由于B依赖了A，故创建B的同时又会去调用<code>getBean(a)</code>来获取A，此时会从三级缓存中进行获取（尚未初始化完成的A）：</p> <ol><li>先获取三级缓存中的对象工厂</li> <li>调用对象工厂的<code>getObject()</code>方法获取A，将其注入到B中。此后B完成后续的初始化流程</li></ol> <p>A等待B初始化完成后将B再注入到属性中，此时A完成后续的初始化流程</p> <p>至此，循环依赖结束</p> <h6 id="为什么要使用三级缓存呢-二级缓存能解决循环依赖吗"><a href="#为什么要使用三级缓存呢-二级缓存能解决循环依赖吗" class="header-anchor">#</a> 为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？</h6> <p>答：如果使用二级缓存解决循环依赖，所有Bean在实例化后（而非初始化阶段）就必须完成AOP代理，这样违背了Spring设计的原则：即，Spring应通过<code>AnnotationAwareAspectJAutoProxyCreator</code>后置处理器在Bean生命周期的最后一步实现AOP代理，而非在实例化后就立即进行AOP代理</p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// DefaultSingletonBeanRegistry.getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) 将初始化完成的Bean单例加入容器</span>

<span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 用ConcurrentHashMap对单实例的Bean对象进行缓存（beanName -&gt; beanInstance）</span>
    <span class="token class-name">Object</span> singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// ...</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// Bean实例的获取</span>
            singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// ...</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
          <span class="token function">afterSingletonCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// ...</span>
        <span class="token comment">// 将Bean对象加入单实例Bean缓存(singletonObjects，单例池）中</span>
        <span class="token function">addSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <h5 id="bean实例化"><a href="#bean实例化" class="header-anchor">#</a> Bean实例化</h5> <ol><li><p><code>createBean(...)</code></p></li> <li><p><code>resolveBeforeInstantiation(...)</code></p></li> <li><p><code>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()</code></p></li> <li><p>[实例化]<code>AbstractAutowireCapableBeanFactory.doCreateBean(...)</code></p> <p><code>AbstractAutowireCapableBeanFactory.instantiateBean(beanName, mbd)</code>，推断构造方法，创建Bean对象</p></li> <li><p><code>AbstractAutowireCapableBeanFactory.populateBean(...)</code></p> <p><code>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</code></p> <p><code>InstantiationAwareBeanPostProcessor.postProcessPropertyValues()</code></p> <p><code>InstantiationAwareBeanPostProcessor.applyPropertyValues()</code></p></li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// AbstractAutowireCapableBeanFactory.createBean(...)</span>

<span class="token comment">// 【实例化前】尝试通过InstantiationAwareBeanPostProcessor获取该Bean的代理对象（InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()）</span>
<span class="token class-name">Object</span> bean <span class="token operator">=</span> <span class="token function">resolveBeforeInstantiation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbdToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// （成功获取代理对象）执行applyBeanPostProcessorsAfterInitialization(..)完成初始化后的收尾处理</span>
<span class="token comment">// ...</span>

<span class="token comment">// 【实例化前】（不能获取代理对象）开始Bean实例的创建</span>
<span class="token class-name">Object</span> beanInstance <span class="token operator">=</span> <span class="token function">doCreateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbdToUse<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> beanInstance<span class="token punctuation">;</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// AbstractAutowireCapableBeanFactory.doCreateBean(...)</span>
  
<span class="token class-name">BeanWrapper</span> instanceWrapper <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  instanceWrapper <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanInstanceCache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>instanceWrapper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  instanceWrapper <span class="token operator">=</span> <span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 【实例化】借助AbstractAutowireCapableBeanFactory.instantiateBean(beanName, mbd)，利用工厂方法直接获取或利用反射调用Bean对象的构造器完成原始Bean对象的初始化</span>
  <span class="token keyword">synchronized</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>postProcessingLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mbd<span class="token punctuation">.</span>postProcessed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">applyMergedBeanDefinitionPostProcessors</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanType<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 遍历所有MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition()方法</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
  
  <span class="token comment">//【实例化后】开始Bean对象的属性赋值与初始化流程</span>
  <span class="token class-name">Object</span> exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 【实例化后】遍历所有InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()及postProcessPropertyValues()方法，其中前者❓，后者❓；最后执行applyPropertyValues()，借助反射调用对象Setter方法等为Bean对象属性赋值</span>
    exposedObject <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 【实例化后】进行Bean初始化</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// ...</span>
  <span class="token comment">// 注册Bean对象的销毁方法</span>
  <span class="token function">registerDisposableBeanIfNecessary</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="bean初始化"><a href="#bean初始化" class="header-anchor">#</a> Bean初始化</h5> <ol start="6"><li><code>InstantiationAwareBeanPostProcessor.initializeBean(...)</code> <ol><li><code>BeanPostProcessor.postProcessBeforeInitialization()</code></li> <li><code>AbstractAutowireCapableBeanFactory.invokeInitMethods(...)</code> <ol><li>[初始化]<code>InitializingBean.afterPropertiesSet()</code>/<code>init()</code></li></ol></li> <li><code>BeanPostProcessor.postProcessAfterInitialization()</code>，尝试借助<code>ProxyFactory</code>构造代理对象，并放入单例池，最终获取完整的Bean对象</li></ol></li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// AbstractAutowireCapableBeanFactory.initializeBean(final String beanName, final Object bean, Object[] args)</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function">invokeAwareMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 【初始化前】执行部分Aware接口回调（BeanNameAware、BeanClassLoaderAware、BeanFactoryAware）；其他有对应后置处理器的Aware接口回调发生在下一步的postProcessoBeforeInitialization()中</span>
  <span class="token comment">// ...</span>
  
  <span class="token class-name">Object</span> wrappedBean <span class="token operator">=</span> bean<span class="token punctuation">;</span>
  <span class="token comment">// ⓵</span>
  wrappedBean <span class="token operator">=</span> <span class="token function">applyBeanPostProcessorsBeforeInitialization</span><span class="token punctuation">(</span>wrappedBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 【初始化前】遍历所有BeanPostProcessors，依次执行postProcessoBeforeInitialization()方法（一旦任一个BeanPostProcessors返回null，则终止遍历）</span>
  
  <span class="token comment">// ...</span>
  <span class="token comment">// ⓶</span>
  <span class="token function">invokeInitMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> wrappedBean<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//【初始化】回调初始化方法</span>
  <span class="token comment">// ...</span>
  wrappedBean <span class="token operator">=</span> <span class="token function">applyBeanPostProcessorsAfterInitialization</span><span class="token punctuation">(</span>wrappedBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 【初始化后】遍历所有BeanPostProcessors.postProcessAfterInitialization()方法</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code>⓵
<span class="token comment">// ApplicationContextAwareProcessor.postProcessBeforeInitialization(Object, String)</span>

<span class="token comment">// 根据所实现的Aware接口类型执行不同操作</span>
<span class="token class-name">ApplicationContextAwareProcessor</span><span class="token punctuation">.</span><span class="token function">invokeAwareInterfaces</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code>⓶
<span class="token comment">// AbstractAutowireCapableBeanFactory.invokeInitMethods(...)</span>

<span class="token comment">// 回调多种初始化方法</span>
<span class="token comment">// 1. 是否实现InitializingBean接口（afterPropertiesSet()）</span>
<span class="token comment">// 2. 是否存在自定义init()方法</span>

<span class="token comment">// （执行其他初始化方法）</span>
</code></pre></div><h1 id="aop"><a href="#aop" class="header-anchor">#</a> AOP</h1> <ol><li><p>若被代理对象没有实现任何接口，则无法使用原生JDK动态代理，因为代理对象与被代理对象之间的唯一关联是所实现的接口</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 在InvocationHandler.invoke(Object, Method, Object[])中对目标方法进行修饰</span>
<span class="token class-name">Object</span> proxy <span class="token operator">=</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>若开启AOP，则容器中保存的是组件的代理对象。若组件实现了接口，则只能通过组件的接口类型访问其代理对象（JDK动态代理）；若组件未实现任何接口，则可通过组件的自身类型访问其代理对象（CGLIB动态代理）</p></li> <li><p>切面类中配置通知方法</p> <p><code>@Before</code>/<code>@After</code>/<code>@AfterReturning</code>/<code>@AfterThrowing</code>/<code>@Around</code></p> <ul><li><p>通知方法的执行顺序：前置通知-&gt;后置通知-&gt;返回/异常通知</p> <ul><li>通知方法注解的切入点表达式中，<code>public</code>为可选（只支持public方法）<code>*</code>匹配全部路径或单层路径，<code>..</code>匹配多层路径（非全部）；<code>*</code>匹配任意类名、任意字符或单个参数，<code>..</code>匹配任意数量参数</li></ul></li> <li><p>在（非环绕）通知方法参数中的<code>JoinPoint</code>对象中获取通知方法的签名和参数列表等信息；在通知方法注解的<code>returning</code>或<code>throwing</code>属性中配置接收通知方法返回值或异常的参数（<code>JoinPoint</code>对象在通知方法参数中必须位于首位）</p></li> <li><p>通知方法可拥有任意访问修饰符和返回值，但其参数表必须唯一确定（Spring通过反射查找该方法的唯一方式）</p></li></ul></li> <li><p>环绕通知优先于普通通知执行（<strong>仅在当前切面类范围内</strong>：环绕前置&lt;-&gt;普通前置-&gt;目标方法-&gt;环绕后置-&gt;普通后置）；必须将<code>proceedingJoinPoint.proceed(Object[] args)</code>结果进行返回或将异常进行抛出，否则普通通知方法无法感知通知方法的返回值或异常</p></li></ol> <blockquote><p>若存在多个切面类，则类名字母顺序在前或<code>@Order</code>注解值越小的先执行</p></blockquote> <h3 id="源码分析"><a href="#源码分析" class="header-anchor">#</a> 源码分析</h3> <h4 id="enableaspectjautoproxy"><a href="#enableaspectjautoproxy" class="header-anchor">#</a> <code>@EnableAspectJAutoProxy</code></h4> <p>利用<code>BeanDefinitionRegistrar</code>向容器中注册<code>AspectJAutoProxyRegistrar</code>，后者向<code>BeanDefinitionRegistry</code>中注册<code>AnnotationAwareAspectJAutoProxyCreator</code></p> <h4 id="annotationawareaspectjautoproxycreator"><a href="#annotationawareaspectjautoproxycreator" class="header-anchor">#</a> <code>AnnotationAwareAspectJAutoProxyCreator</code></h4> <h5 id="初始化"><a href="#初始化" class="header-anchor">#</a> 初始化</h5> <ol><li><code>registerBeanPostProcessors(beanFactory);</code>创建所需的BeanPostProcessor，并注册进BeanFactory</li> <li><code>finishBeanFactoryInitialization(beanFactory);</code>创建剩余的单例Bean（如非后置处理器类型的其他Bean），完成BeanFactory初始化</li></ol> <h5 id="aop相关类的包装"><a href="#aop相关类的包装" class="header-anchor">#</a> AOP相关类的包装</h5> <h6 id="aop相关类的初始化"><a href="#aop相关类的初始化" class="header-anchor">#</a> AOP相关类的初始化</h6> <ol><li>判断AOP关注点所在类是否已存在于缓存（<code>advicedBeans</code>）中</li> <li>判断AOP关注点所在类是否实现了<code>Advice</code>/<code>Pointcut</code>/<code>Advisor</code>/<code>AopInfrastructureBean</code>等基础接口，或是否标注有<code>@Aspect</code>注解（是否是切面类）</li> <li>判断是否需要跳过（当该类为<code>AspectJPointcutAdvisor</code>类型时跳过）</li> <li>调用AOP关注点所在类的构造方法</li></ol> <h6 id="aop相关类的初始化后"><a href="#aop相关类的初始化后" class="header-anchor">#</a> AOP相关类的初始化后</h6> <p><code>wrapIfNecessary(Object bean, String beanName, String cacheKey)</code>将AOP关注点所在类包装为代理对象</p> <ol><li><code>AbstractAdvisorAutoProxyCreator.getAdviceAndAdvisorsForBean(..)</code>遍历所有增强器依次判断是否匹配，获取当前Bean所有能使用的增强器并<strong>排序</strong>返回（拦截器，即通知方法）</li> <li>将当前Bean保存至<code>advicedBeans</code></li> <li>为当前Bean创建代理对象
<ol><li>获取所有可用的增强器，保存至<code>proxyFactory</code></li> <li>使用<code>proxyFactory</code>创建<code>JdkDynamicAopProxy</code>或<code>ObjenesisCglibAopProxy</code>代理对象</li></ol></li></ol> <h5 id="aop的执行流程"><a href="#aop的执行流程" class="header-anchor">#</a> AOP的执行流程</h5> <p><code>CglibAopProxy.intercept()</code></p> <ol><li><p><code>DefaultAdvisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(..)</code>尝试获取关注点方法的<strong>有序</strong>拦截器链（<code>MethodInterceptor</code>）</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">getInterceptorsAndDynamicInterceptionAdvice</span><span class="token punctuation">(</span>
			<span class="token class-name">Advised</span> config<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 遍历所有增强器，根据实现接口的不同包装为org.aopalliance.intercept.MethodInterceptor对象</span>
  		<span class="token keyword">if</span> <span class="token punctuation">(</span>advisor <span class="token keyword">instanceof</span> <span class="token class-name">PointcutAdvisor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// ...</span>
			<span class="token punctuation">}</span>	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>advisor <span class="token keyword">instanceof</span> <span class="token class-name">IntroductionAdvisor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// ...</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
				<span class="token class-name">Interceptor</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interceptors <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">getInterceptors</span><span class="token punctuation">(</span>advisor<span class="token punctuation">)</span><span class="token punctuation">;</span>
				interceptorList<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>interceptors<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
  	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>（若无法获取拦截器链）直接执行目标方法；</p> <p>（若成功获取拦截器链）将关注点方法信息以及拦截器链包装为<code>CglibMethodInvocation</code>对象，并调用其<code>proceed()</code>方法</p> <blockquote><p>在该方法中<strong>链式获取</strong>所有可用的拦截器，执行其<code>invoke(CglibMethodInvocation)</code>方法：</p> <ul><li>如果拦截器非<code>MethodBeforeAdviceInterceptor</code>，则继续调用<code>CglibMethodInvocation</code>的<code>proceed()</code>，<code>proceed()</code>返回之后再执行通知方法</li> <li>如果拦截器为<code>MethodBeforeAdviceInterceptor</code>（拦截器链最后一组），则先执行增强器的通知方法，再继续调用<code>CglibMethodInvocation</code>的<code>proceed()</code>：此处由于已遍历至拦截器链末尾，则调用<code>invokeJoinpoint()</code>执行切入点方法</li></ul></blockquote> <p>通过拦截器链，保证通知方法与切入点方法之间的执行顺序</p></li></ol> <blockquote><h5 id="aop自调用解决方案"><a href="#aop自调用解决方案" class="header-anchor">#</a> AOP自调用解决方案</h5></blockquote> <h2 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h2> <ul><li><code>REQUIRED</code></li> <li><code>SUPPORTS</code></li> <li><code>MANDATORY</code></li> <li><code>REQUIRES_NEW</code></li> <li><code>NOT_SUPPORTED</code></li> <li><code>NEVER</code></li> <li><code>NESTED</code></li></ul> <h4 id="编程式事务"><a href="#编程式事务" class="header-anchor">#</a> 编程式事务</h4> <p><code>PlatformTransactionManager</code>接口</p> <h4 id="声明式事务"><a href="#声明式事务" class="header-anchor">#</a> 声明式事务</h4> <h6 id="abstractplatformtransactionmanager"><a href="#abstractplatformtransactionmanager" class="header-anchor">#</a> <code>AbstractPlatformTransactionManager</code></h6> <h6 id="enabletransactionmanagement"><a href="#enabletransactionmanagement" class="header-anchor">#</a> <code>@EnableTransactionManagement</code></h6> <p>通过<code>TransactionManagementConfigurationSelector</code>，默认向容器中导入<code>AutoProxyRegistrar</code>和<code>ProxyTransactionManagementConfiguration</code>，前者向容器中注册<code>InfrastructureAdvisorAutoProxyCreator</code>，后者向容器中注册<code>BeanFactoryTransactionAttributeSourceAdvisor</code></p> <h6 id="beanfactorytransactionattributesourceadvisor"><a href="#beanfactorytransactionattributesourceadvisor" class="header-anchor">#</a> <code>BeanFactoryTransactionAttributeSourceAdvisor</code></h6> <ol><li>借助<code>AnnotationTransactionAttributeSource</code>中的注解解析器解析<code>@Transactional</code>注解配置信息</li> <li>向<code>TransactionInterceptor</code>注入注解解析器与事务管理器<code>PlatformTransactionManager</code>（通过<code>@Qualifier</code>指定或从容器中获取事务管理器）</li> <li>在代理对象执行目标方法时，通过事务拦截器链（中的事务管理器）进行事务控制</li></ol> <h1 id="扩展组件"><a href="#扩展组件" class="header-anchor">#</a> 扩展组件</h1> <h4 id="beanfactorypostprocessor"><a href="#beanfactorypostprocessor" class="header-anchor">#</a> <code>BeanFactoryPostProcessor</code></h4> <p><code>BeanFactoryPostProcessor.postProcessBeanFactory()</code></p> <p>在BeanFactory标准初始化完成后调用，此时Bean定义信息已被加载至BeanFactory，但尚未进行实例化</p> <h4 id="beandefinitionregistrypostprocessor"><a href="#beandefinitionregistrypostprocessor" class="header-anchor">#</a> <code>BeanDefinitionRegistryPostProcessor</code></h4> <p>在Bean定义信息将被加载至BeanFactory之前调用</p> <p>先执行<code>BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry()</code>，再执行<code>BeanDefinitionRegistryPostProcessor.postProcessBeanFactory()</code>，再执行<code>BeanFactoryPostProcessor</code>的回调方法</p> <blockquote><p>用于在BeanFactory初始化完成之前向容器工厂添加额外的组件</p></blockquote> <h4 id="applicationlistener"><a href="#applicationlistener" class="header-anchor">#</a> <code>ApplicationListener</code></h4> <p>监听容器内发布的事件（事件继承至<code>ApplicationEvent</code>）</p> <p><code>@EventListener</code></p> <p>借助<code>EventListenerMethodProcessor</code>解析注解上的事件监听信息，而该方法处理器实现了<code>SmartInitializingSinglton</code>接口</p> <h6 id="smartinitializingsingleton"><a href="#smartinitializingsingleton" class="header-anchor">#</a> <code>SmartInitializingSingleton</code></h6> <p>在容器内所有非懒加载的单例Bean都初始化完成（<code>finishBeanFactoryInitialization(beanFactory)</code>）后，容器结束刷新（<code>finishRefresh()</code>）前调用</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
				←
				<a href="/posts/java/jvm.html" class="prev">
					JVM
				</a></span> <span class="next"><a href="/posts/java/springboot.html">
					Spring Boot基础
				</a>
				→
			</span></p></div> <div class="vcomment-container" data-v-07c8026b><div id="vcomments" data-v-07c8026b></div></div> </main> <!----></div><div class="global-ui"><!----><div></div></div></div>
    <script src="/assets/js/app.9bbd0500.js" defer></script><script src="/assets/js/1.7e1accfd.js" defer></script><script src="/assets/js/13.b5619b2f.js" defer></script><script src="/assets/js/22.d26d3f4d.js" defer></script>
  </body>
</html>
